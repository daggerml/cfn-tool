// Generated by CoffeeScript 2.5.1
(function() {
  var YamlTransformer, assert, fn, yaml;

  yaml = require('js-yaml');

  assert = require('assert');

  fn = require('./fn');

  //=============================================================================#
  // TRANSFORMER BASE CLASS                                                      #
  //=============================================================================#
  YamlTransformer = class YamlTransformer {
    constructor() {
      this.tags = [];
      this.macros = {};
      this.specials = {};
      this.keystack = [];
      this.objstack = [];
    }

    abort(...msg) {
      throw new Error(`at ${this.keystack.join('/')}: ${msg.join(' ')}`);
    }

    walkObject(xs) {
      var ks;
      ks = Object.keys(xs);
      return this.withObj(xs, () => {
        return ks.reduce(((ret, k) => {
          var v;
          v = xs[k];
          return this.withKey(k, () => {
            var m, s;
            v = (s = this.specials[k]) ? s(v) : (m = this.macros[k]) ? m(this.walk(v)) : fn.hashMap(k, this.walk(v));
            if (ks.length === 1) {
              return v;
            } else {
              return fn.merge(ret, fn.assertObject(v));
            }
          });
        }), {});
      });
    }

    walkArray(xs) {
      return this.withObj(xs, () => {
        return xs.map((v, i) => {
          return this.withKey(`${i}`, () => {
            return this.walk(v);
          });
        });
      });
    }

    walk(thing) {
      var ret;
      ret = (function() {
        switch (fn.typeOf(thing)) {
          case 'Object':
            return this.walkObject(thing);
          case 'Array':
            return this.walkArray(thing);
          default:
            return thing;
        }
      }).call(this);
      if (fn.deepEqual(thing, ret)) {
        return ret;
      } else {
        return this.walk(ret);
      }
    }

    withObj(obj, f) {
      var ret;
      this.objstack.push(obj);
      ret = f();
      this.objstack.pop();
      return ret;
    }

    withKey(key, f) {
      var ret;
      this.keystack.push(key != null ? typeof key.split === "function" ? key.split(/ +/).shift().replace(/^Fn::/, '!') : void 0 : void 0);
      ret = f();
      this.keystack.pop();
      return ret;
    }

    deftag(tag, long) {
      var emit, j, kind, len, ref;
      emit = function(form) {
        return fn.hashMap(long, form);
      };
      ref = ['scalar', 'sequence', 'mapping'];
      for (j = 0, len = ref.length; j < len; j++) {
        kind = ref[j];
        this.tags.push(new yaml.Type(tag, {
          kind,
          construct: emit
        }));
      }
      return this;
    }

    _defform(namespace, tag, long, emit) {
      var short;
      short = `!${tag}`;
      if (long == null) {
        long = `Fn::${tag}`;
      }
      this.deftag(short, long);
      if (emit) {
        namespace[long] = (...args) => {
          var e;
          try {
            return emit.apply(null, args);
          } catch (error) {
            e = error;
            return this.abort(e);
          }
        };
      }
      return this;
    }

    defspecial(tag, long, emit) {
      if (!emit) {
        [long, emit] = [emit, long];
      }
      return this._defform(this.specials, tag, long, emit);
    }

    defmacro(tag, long, emit) {
      if (!emit) {
        [long, emit] = [emit, long];
      }
      return this._defform(this.macros, tag, long, emit);
    }

    parse(textOrDoc) {
      if (!fn.isString(textOrDoc)) {
        return textOrDoc;
      }
      return yaml.safeLoad(textOrDoc, {
        schema: yaml.Schema.create(this.tags)
      });
    }

    dump(doc) {
      return yaml.safeDump(doc);
    }

    transform(textOrDoc) {
      this.keystack.splice(0);
      this.objstack.splice(0);
      return this.dump(this.walk(this.parse(textOrDoc)));
    }

  };

  module.exports = YamlTransformer;

}).call(this);

//# sourceMappingURL=yaml-transformer.js.map
