// Generated by CoffeeScript 2.5.1
(function() {
  var YamlTransformer, assert, assertObject, deepEqual, hashMap, merge, split, typeOf, yaml;

  yaml = require('js-yaml');

  assert = require('assert');

  typeOf = function(thing) {
    return Object.prototype.toString.call(thing).slice(8, -1);
  };

  split = function(str, sep, count = 2e308) {
    var n, toks;
    toks = str.split(sep);
    n = Math.min(toks.length, count) - 1;
    return toks.slice(0, n).concat(toks.slice(n).join(sep));
  };

  assertObject = function(thing) {
    var ref;
    assert.ok((ref = typeOf(thing)) === 'Object' || ref === 'Undefined' || ref === 'Null', `expected an Object, got ${JSON.stringify(thing)}`);
    return thing;
  };

  hashMap = function(...args) {
    var i, j, ref, ret;
    ret = {};
    for (i = j = 0, ref = args.length / 2; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      ret[args[2 * i]] = args[2 * i + 1];
    }
    return ret;
  };

  merge = function(...args) {
    return Object.assign.apply(null, args);
  };

  deepEqual = function(x, y) {
    var e;
    try {
      return !assert.deepEqual(x, y);
    } catch (error) {
      e = error;
      return false;
    }
  };

  //=============================================================================#
  // TRANSFORMER BASE CLASS                                                      #
  //=============================================================================#
  YamlTransformer = class YamlTransformer {
    constructor() {
      this.tags = [];
      this.macros = {};
      this.specials = {};
      this.keystack = [];
      this.objstack = [];
    }

    abort(...msg) {
      throw new Error(`at ${this.keystack.join('/')}: ${msg.join(' ')}`);
    }

    walkObject(xs) {
      var ks;
      ks = Object.keys(xs);
      return this.withObj(xs, () => {
        return ks.reduce(((ret, k) => {
          var v;
          v = xs[k];
          return this.withKey(k, () => {
            var m, s;
            v = (s = this.specials[k]) ? s(v) : (m = this.macros[k]) ? m(this.walk(v)) : hashMap(k, this.walk(v));
            if (ks.length === 1) {
              return v;
            } else {
              return merge(ret, assertObject(v));
            }
          });
        }), {});
      });
    }

    walkArray(xs) {
      return this.withObj(xs, () => {
        return xs.map((v, i) => {
          return this.withKey(`${i}`, () => {
            return this.walk(v);
          });
        });
      });
    }

    walk(thing) {
      var ret;
      ret = (function() {
        switch (typeOf(thing)) {
          case 'Object':
            return this.walkObject(thing);
          case 'Array':
            return this.walkArray(thing);
          default:
            return thing;
        }
      }).call(this);
      if (deepEqual(thing, ret)) {
        return ret;
      } else {
        return this.walk(ret);
      }
    }

    withObj(obj, f) {
      var ret;
      this.objstack.push(obj);
      ret = f();
      this.objstack.pop();
      return ret;
    }

    withKey(key, f) {
      var ret;
      this.keystack.push(key != null ? typeof key.split === "function" ? key.split(/ +/).shift().replace(/^Fn::/, '!') : void 0 : void 0);
      ret = f();
      this.keystack.pop();
      return ret;
    }

    deftag(tag, long) {
      var emit, j, kind, len, ref;
      emit = function(form) {
        return hashMap(long, form);
      };
      ref = ['scalar', 'sequence', 'mapping'];
      for (j = 0, len = ref.length; j < len; j++) {
        kind = ref[j];
        this.tags.push(new yaml.Type(tag, {
          kind,
          construct: emit
        }));
      }
      return this;
    }

    _defform(namespace, tag, long, emit) {
      var short;
      short = `!${tag}`;
      if (long == null) {
        long = `Fn::${tag}`;
      }
      this.deftag(short, long);
      if (emit) {
        namespace[long] = (...args) => {
          var e;
          try {
            return emit.apply(null, args);
          } catch (error) {
            e = error;
            return this.abort(e);
          }
        };
      }
      return this;
    }

    defspecial(tag, long, emit) {
      if (!emit) {
        [long, emit] = [emit, long];
      }
      return this._defform(this.specials, tag, long, emit);
    }

    defmacro(tag, long, emit) {
      if (!emit) {
        [long, emit] = [emit, long];
      }
      return this._defform(this.macros, tag, long, emit);
    }

    parse(textOrDoc) {
      if (typeOf(textOrDoc) !== 'String') {
        return textOrDoc;
      }
      return yaml.safeLoad(textOrDoc, {
        schema: yaml.Schema.create(this.tags)
      });
    }

    dump(doc) {
      return yaml.safeDump(doc);
    }

    transform(textOrDoc) {
      this.keystack.splice(0);
      this.objstack.splice(0);
      return this.dump(this.walk(this.parse(textOrDoc)));
    }

  };

  module.exports = YamlTransformer;

}).call(this);

//# sourceMappingURL=yaml-transformer.js.map
