// Generated by CoffeeScript 2.5.1
(function() {
  var Logger, MESSAGE, basename, createLogger, levels, stderr, winston;

  ({createLogger} = winston = require('winston'));

  ({stderr} = require('chalk'));

  ({MESSAGE} = require('triple-beam'));

  ({basename} = require('path'));

  levels = {
    console: 0,
    error: 0,
    warn: 1,
    info: 2,
    verbose: 3,
    spawn: 4
  };

  Logger = class Logger {
    constructor() {
      var format, transports;
      format = (winston.format((info, opts) => {
        var body, color, colors, lines, message1, message2, ref, ref1, verbose;
        colors = {
          error: stderr.red,
          warn: stderr.yellow,
          info: stderr,
          verbose: stderr
        };
        if (!((ref = info.level) === 'console' || ref === 'spawn')) {
          color = colors[info.level];
          verbose = levels[this.logger.level] > levels.info || levels[info.level] < levels.info;
          lines = info.message.split('\n').map(function(x) {
            return x.trimRight();
          }).filter(function(x) {
            return x;
          });
          message1 = color.bold(`${this.PROG}: ${lines.shift()}`);
          if (lines.length) {
            message2 = color(lines.join('\n'));
          }
          if (info.body && verbose) {
            body = stderr.dim(info.body);
          }
          info[MESSAGE] = [message1, message2, body].filter(function(x) {
            return x;
          }).join('\n');
        } else {
          info[MESSAGE] = info.message;
        }
        if ((ref1 = this.SIDE_EFFECTS) != null) {
          ref1.push(info);
        }
        return info;
      }))();
      transports = [
        new winston.transports.Console({
          stderrLevels: ['error',
        'warn',
        'info',
        'verbose']
        })
      ];
      this.PROG = basename(process.argv[1] || 'repl');
      this.SIDE_EFFECTS = null;
      this.logger = createLogger({levels, format, transports});
    }

    level(x) {
      if (this.logger.level !== 'console') {
        return this.logger.level = x;
      }
    }

    silence(enable) {
      var i, len, ref, x;
      ref = this.logger.transports;
      for (i = 0, len = ref.length; i < len; i++) {
        x = ref[i];
        (x.silent = !!enable);
      }
      return this.SIDE_EFFECTS = enable ? this.SIDE_EFFECTS || [] : null;
    }

    sideEffects() {
      return this.SIDE_EFFECTS;
    }

  };

  Object.keys(levels).forEach(function(x) {
    return Logger.prototype[x] = function(...xs) {
      if (xs != null ? xs[0] : void 0) {
        return this.logger[x].apply(this.logger, xs);
      }
    };
  });

  module.exports = new Logger();

}).call(this);

//# sourceMappingURL=log.js.map
