// Generated by CoffeeScript 2.5.1
(function() {
  var CfnError, MOCKS, TESTING, abortOnException, assert, assertArray, assertObject, assertOk, assertString, assoc, conj, crypto, dbg, deepEqual, deepMerge, execShell, execShellArgs, fileExt, fs, getIn, getMock, handleShell, hashMap, identity, invertObj, isArray, isBoolean, isCollection, isDirectory, isNull, isNumber, isObject, isRef, isScalar, isString, isUndefined, log, md5, md5Dir, md5File, md5Path, merge, mergeStrings, mockSpawn, notEmpty, objKeys, objVals, os, partial, path, peek, prependLines, readFile, reduceKv, rmCR, selectKeys, spawn, spawnSync, split, testing, tmpdir, tryExecRaw, typeOf,
    indexOf = [].indexOf;

  assert = require('assert');

  ({spawnSync} = require('child_process'));

  crypto = require('crypto');

  fs = require('fs');

  os = require('os');

  path = require('path');

  log = require('./log');

  CfnError = require('./CfnError');

  //------------------------------------------------------------------------------
  // debugging functions
  //------------------------------------------------------------------------------
  TESTING = false;

  testing = module.exports.testing = function(enable) {
    if (enable == null) {
      return TESTING;
    }
    log.silence(!!enable);
    return TESTING = !!enable;
  };

  dbg = module.exports.dbg = function(x) {
    console.log(require('util').inspect({
      dbg: x
    }, {
      depth: null
    }));
    return x;
  };

  //------------------------------------------------------------------------------
  // crypto functions
  //------------------------------------------------------------------------------
  md5 = module.exports.md5 = function(data) {
    return crypto.createHash("md5").update(data).digest("hex");
  };

  md5File = module.exports.md5File = function(filePath) {
    return md5(fs.readFileSync(filePath));
  };

  md5Dir = module.exports.md5Dir = function(dirPath) {
    var add2tree, origDir;
    origDir = process.cwd();
    try {
      process.chdir(dirPath);
      add2tree = function(tree, path) {
        return assoc(tree, path, md5Path(path));
      };
      return md5(JSON.stringify(fs.readdirSync('.').sort().reduce(add2tree, {})));
    } finally {
      process.chdir(origDir);
    }
  };

  md5Path = module.exports.md5Path = function(path) {
    return (isDirectory(path) ? md5Dir : md5File)(path);
  };

  //------------------------------------------------------------------------------
  // collection functions
  //------------------------------------------------------------------------------
  assoc = module.exports.assoc = function(xs, k, v) {
    xs[k] = v;
    return xs;
  };

  conj = module.exports.conj = function(xs, x) {
    xs.push(x);
    return xs;
  };

  merge = module.exports.merge = function(...args) {
    return Object.assign.apply(null, args);
  };

  deepMerge = module.exports.deepMerge = function(...args) {
    var dm;
    dm = function(x, y) {
      var k, ret, v;
      if (!(isObject(x) && isObject(y))) {
        return y;
      } else {
        ret = Object.assign({}, x);
        for (k in y) {
          v = y[k];
          ret[k] = dm(x[k], v);
        }
        return ret;
      }
    };
    return args.reduce((function(xs, x) {
      return dm(xs, x);
    }), {});
  };

  hashMap = module.exports.hashMap = function(...args) {
    var i, j, ref, ret;
    ret = {};
    for (i = j = 0, ref = args.length / 2; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      ret[args[2 * i]] = args[2 * i + 1];
    }
    return ret;
  };

  objKeys = module.exports.objKeys = function(x) {
    return Object.keys(x);
  };

  objVals = module.exports.objVals = function(x) {
    return objKeys(x).reduce((function(ys, y) {
      return ys.concat([x[y]]);
    }), []);
  };

  reduceKv = module.exports.reduceKv = function(map, f) {
    return Object.keys(map).reduce((function(xs, k) {
      return f(xs, k, map[k]);
    }), {});
  };

  selectKeys = module.exports.selectKeys = function(o, ks) {
    return Object.keys(o).reduce((function(xs, x) {
      if (indexOf.call(ks, x) >= 0) {
        return assoc(xs, x, o[x]);
      } else {
        return xs;
      }
    }), {});
  };

  notEmpty = module.exports.notEmpty = function(map) {
    return Object.keys(map || {}).length > 0;
  };

  invertObj = module.exports.invertObj = function(o) {
    return Object.keys(o).reduce((function(xs, x) {
      return assoc(xs, o[x], x);
    }), {});
  };

  peek = module.exports.peek = function(ary) {
    return ary[ary.length - 1];
  };

  getIn = module.exports.getIn = function(obj, ks) {
    return ks.reduce((function(xs, x) {
      return xs[x];
    }), obj);
  };

  //------------------------------------------------------------------------------
  // string functions
  //------------------------------------------------------------------------------
  split = module.exports.split = function(str, sep, count = 2e308) {
    var n, toks;
    toks = str.split(sep);
    n = Math.min(toks.length, count) - 1;
    return toks.slice(0, n).concat(toks.slice(n).join(sep));
  };

  mergeStrings = module.exports.mergeStrings = function(toks, sep = '') {
    var reducer;
    reducer = function(xs, x) {
      var y;
      if (!isObject(x)) {
        x = `${x}`;
      }
      y = xs.pop();
      return xs.concat(isString(x) && isString(y) ? [[y, x].join(sep)] : [y, x]);
    };
    return toks.reduce(reducer, []).filter(function(x) {
      return (x != null) && x !== '';
    });
  };

  prependLines = module.exports.prependLines = function(x, prefix) {
    if (!(x && isString(x))) {
      return null;
    }
    return x.split(/\n/).map(function(x) {
      return x.trimRight();
    }).filter(identity).map(function(x) {
      return `${prefix}| ${x}`;
    }).join('\n');
  };

  rmCR = module.exports.rmCR = function(x = '') {
    var j, l, len, len1, lines, ref, ref1, v, w;
    lines = [];
    ref = x.split(/\r/);
    for (j = 0, len = ref.length; j < len; j++) {
      v = ref[j];
      if (v[0] === '\n') {
        v = v.slice(1);
      } else {
        lines.pop();
      }
      ref1 = v.split(/\n/);
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        w = ref1[l];
        lines.push(w);
      }
    }
    return lines.join('\n');
  };

  //------------------------------------------------------------------------------
  // type functions
  //------------------------------------------------------------------------------
  typeOf = module.exports.typeOf = function(thing) {
    return Object.prototype.toString.call(thing).slice(8, 11);
  };

  isString = module.exports.isString = function(x) {
    return typeOf(x) === 'Str';
  };

  isNumber = module.exports.isNumber = function(x) {
    return typeOf(x) === 'Num';
  };

  isArray = module.exports.isArray = function(x) {
    return typeOf(x) === 'Arr';
  };

  isObject = module.exports.isObject = function(x) {
    return typeOf(x) === 'Obj';
  };

  isBoolean = module.exports.isBoolean = function(x) {
    return typeOf(x) === 'Boo';
  };

  isNull = module.exports.isNull = function(x) {
    return typeOf(x) === 'Nul';
  };

  isUndefined = module.exports.isUndefined = function(x) {
    return typeOf(x) === 'Und';
  };

  isScalar = module.exports.isScalar = function(x) {
    var ref;
    return (ref = typeOf(x)) === 'Str' || ref === 'Num' || ref === 'Boo' || ref === 'Nul';
  };

  isCollection = module.exports.isCollection = function(x) {
    var ref;
    return (ref = typeOf(x)) === 'Arr' || ref === 'Obj';
  };

  //------------------------------------------------------------------------------
  // assertion functions
  //------------------------------------------------------------------------------
  assertOk = module.exports.assertOk = function(x, msg, body) {
    if (!x) {
      throw new CfnError(msg, body);
    }
    return x;
  };

  assertObject = module.exports.assertObject = function(thing) {
    var ref;
    assert.ok((ref = typeOf(thing)) === 'Obj' || ref === 'Nul', `expected an Object, got ${JSON.stringify(thing)}`);
    return thing;
  };

  assertArray = module.exports.assertArray = function(thing) {
    assert.ok(isArray(thing), `expected an Array, got ${JSON.stringify(thing)}`);
    return thing;
  };

  assertString = module.exports.assertString = function(thing) {
    assert.ok(isString(thing), `expected a String, got ${JSON.stringify(thing)}`);
    return thing;
  };

  //------------------------------------------------------------------------------
  // filesystem I/O functions
  //------------------------------------------------------------------------------
  tmpdir = module.exports.tmpdir = function(prefix, keep = false) {
    var dir;
    dir = fs.mkdtempSync([os.tmpdir(), prefix].join('/'));
    process.on('exit', function() {
      if (!keep) {
        return fs.rmdirSync(dir, {
          recursive: true
        });
      }
    });
    return dir;
  };

  isDirectory = module.exports.isDirectory = function(file) {
    return fs.statSync(file).isDirectory();
  };

  fileExt = module.exports.fileExt = function(file) {
    var e;
    if ((e = split(path.basename(file), '.', 2)[1]) != null) {
      return `.${e}`;
    }
  };

  readFile = module.exports.readFile = function(file) {
    return fs.readFileSync(file).toString('utf-8');
  };

  abortOnException = module.exports.abortOnException = function(abort, lib, fn) {
    return (typeOf(fn) === 'Array' ? fn : [fn]).forEach(function(x) {
      return global[x] = function(...args) {
        var e;
        try {
          return lib[x].apply(lib, args);
        } catch (error) {
          e = error;
          return abort(e);
        }
      };
    });
  };

  //------------------------------------------------------------------------------
  // child process functions
  //------------------------------------------------------------------------------
  MOCKS = [];

  mockSpawn = module.exports.mockSpawn = function(f) {
    return MOCKS.push(f);
  };

  getMock = function(cmd) {
    var f, j, len, ret;
    for (j = 0, len = MOCKS.length; j < len; j++) {
      f = MOCKS[j];
      if ((ret = f(cmd))) {
        return ret;
      }
    }
    return null;
  };

  handleShell = module.exports.handleShell = function(cmd, res, raw) {
    var ref, ref1, stderr, stdout;
    cmd = prependLines(cmd, 'cmd');
    stdout = rmCR((ref = res.stdout) != null ? ref.toString('utf-8') : void 0);
    stderr = rmCR((ref1 = res.stderr) != null ? ref1.toString('utf-8') : void 0);
    res.out = prependLines(stdout, 'out');
    res.err = prependLines(stderr, 'err');
    res.all = [res.out, res.err].filter(identity).join('\n');
    if (raw) {
      return res;
    } else {
      if (res.status === 0) {
        log.verbose("bash: status 0", {
          body: `${cmd}\n${res.all}`
        });
        return stdout;
      } else {
        throw new CfnError(`bash: exit status ${res.status}`, `${cmd}\n${res.all}`);
      }
    }
  };

  spawn = function(cmd, ...args) {
    if (TESTING) {
      log.spawn(cmd);
      return getMock(cmd) || {
        status: 0,
        stdout: "bogus stdout",
        stderr: "bogus stderr"
      };
    } else {
      return spawnSync.apply(null, [cmd].concat(args));
    }
  };

  execShell = module.exports.execShell = function(cmd, opts, raw = false) {
    var res;
    res = spawn(cmd, merge({
      stdio: 'pipe',
      shell: '/bin/bash'
    }, opts));
    return handleShell(cmd, res, raw);
  };

  execShellArgs = module.exports.execShellArgs = function(cmd, args, opts, raw = false) {
    var res;
    res = spawn(cmd, args, merge({
      stdio: 'pipe',
      shell: '/bin/bash'
    }, opts));
    return handleShell(cmd, res, raw);
  };

  tryExecRaw = module.exports.tryExecRaw = function(cmd, msg) {
    var res;
    res = execShell(cmd, null, true);
    cmd = prependLines(cmd, 'cmd');
    if (res.status === 0) {
      return log.verbose("bash: status 0", {
        body: `${cmd}\n${res.all}`
      });
    } else {
      log.verbose(`bash: exit status ${res.status}`, {
        body: cmd
      });
      throw new CfnError(msg, res.all);
    }
  };

  //------------------------------------------------------------------------------
  // misc functions
  //------------------------------------------------------------------------------
  isRef = module.exports.isRef = function(x) {
    return x && isObject(x) && deepEqual(objKeys(x), ['Ref']) && x.Ref !== 'AWS::NoValue';
  };

  identity = module.exports.identity = function(x) {
    return x;
  };

  partial = module.exports.partial = function(f, obj, ...args) {
    return function(...args2) {
      return f.apply(obj, args.concat(args2));
    };
  };

  deepEqual = module.exports.deepEqual = function(x, y) {
    var e;
    try {
      return !assert.deepEqual(x, y);
    } catch (error) {
      e = error;
      return false;
    }
  };

}).call(this);

//# sourceMappingURL=fn.js.map
