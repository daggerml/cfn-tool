// Generated by CoffeeScript 2.5.1
(function() {
  var CfnError, abortOnException, assert, assertArray, assertObject, assertOk, assoc, conj, crypto, dbg, deepEqual, deepMerge, fileExt, fs, getIn, hashMap, identity, invertObj, isArray, isBoolean, isDirectory, isObject, isString, md5, md5Dir, md5File, md5Path, merge, mergeStrings, notEmpty, objKeys, objVals, path, peek, prependLines, readFile, reduceKv, rmCR, selectKeys, split, typeOf,
    indexOf = [].indexOf;

  assert = require('assert');

  crypto = require('crypto');

  fs = require('fs');

  path = require('path');

  CfnError = require('./CfnError');

  dbg = function(x) {
    console.log(require('util').inspect({
      dbg: x
    }, {
      depth: null
    }));
    return x;
  };

  md5 = function(data) {
    return crypto.createHash("md5").update(data).digest("hex");
  };

  md5File = function(filePath) {
    return md5(fs.readFileSync(filePath));
  };

  md5Dir = function(dirPath) {
    var add2tree, origDir;
    origDir = process.cwd();
    try {
      process.chdir(dirPath);
      add2tree = function(tree, path) {
        return assoc(tree, path, md5Path(path));
      };
      return md5(JSON.stringify(fs.readdirSync('.').sort().reduce(add2tree, {})));
    } finally {
      process.chdir(origDir);
    }
  };

  md5Path = function(path) {
    return (isDirectory(path) ? md5Dir : md5File)(path);
  };

  identity = function(x) {
    return x;
  };

  assoc = function(xs, k, v) {
    xs[k] = v;
    return xs;
  };

  conj = function(xs, x) {
    xs.push(x);
    return xs;
  };

  merge = function(...args) {
    return Object.assign.apply(null, args);
  };

  deepMerge = function(...args) {
    var dm;
    dm = function(x, y) {
      var k, ret, v;
      if (!(isObject(x) && isObject(y))) {
        return y;
      } else {
        ret = Object.assign({}, x);
        for (k in y) {
          v = y[k];
          ret[k] = dm(x[k], v);
        }
        return ret;
      }
    };
    return args.reduce((function(xs, x) {
      return dm(xs, x);
    }), {});
  };

  hashMap = function(...args) {
    var i, j, ref, ret;
    ret = {};
    for (i = j = 0, ref = args.length / 2; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      ret[args[2 * i]] = args[2 * i + 1];
    }
    return ret;
  };

  objKeys = function(x) {
    return Object.keys(x);
  };

  objVals = function(x) {
    return objKeys(x).reduce((function(ys, y) {
      return ys.concat([x[y]]);
    }), []);
  };

  reduceKv = function(map, f) {
    return Object.keys(map).reduce((function(xs, k) {
      return f(xs, k, map[k]);
    }), {});
  };

  selectKeys = function(o, ks) {
    return Object.keys(o).reduce((function(xs, x) {
      if (indexOf.call(ks, x) >= 0) {
        return assoc(xs, x, o[x]);
      } else {
        return xs;
      }
    }), {});
  };

  notEmpty = function(map) {
    return Object.keys(map || {}).length > 0;
  };

  invertObj = function(o) {
    return Object.keys(o).reduce((function(xs, x) {
      return assoc(xs, o[x], x);
    }), {});
  };

  peek = function(ary) {
    return ary[ary.length - 1];
  };

  getIn = function(obj, ks) {
    return ks.reduce((function(xs, x) {
      return xs[x];
    }), obj);
  };

  split = function(str, sep, count = 2e308) {
    var n, toks;
    toks = str.split(sep);
    n = Math.min(toks.length, count) - 1;
    return toks.slice(0, n).concat(toks.slice(n).join(sep));
  };

  assertOk = function(x, msg, body) {
    if (!x) {
      throw new CfnError(msg, body);
    }
    return x;
  };

  typeOf = function(thing) {
    return Object.prototype.toString.call(thing).slice(8, -1);
  };

  isString = function(x) {
    return typeOf(x) === 'String';
  };

  isArray = function(x) {
    return typeOf(x) === 'Array';
  };

  isObject = function(x) {
    return typeOf(x) === 'Object';
  };

  isBoolean = function(x) {
    return typeOf(x) === 'Boolean';
  };

  assertObject = function(thing) {
    var ref;
    assert.ok((ref = typeOf(thing)) === 'Object' || ref === 'Undefined' || ref === 'Null', `expected an Object, got ${JSON.stringify(thing)}`);
    return thing;
  };

  assertArray = function(thing) {
    assert.ok(isArray(thing), `expected an Array, got ${JSON.stringify(thing)}`);
    return thing;
  };

  isDirectory = function(file) {
    return fs.statSync(file).isDirectory();
  };

  fileExt = function(file) {
    var e;
    if ((e = split(path.basename(file), '.', 2)[1]) != null) {
      return `.${e}`;
    }
  };

  readFile = function(file) {
    return fs.readFileSync(file).toString('utf-8');
  };

  abortOnException = function(abort, lib, fn) {
    return (typeOf(fn) === 'Array' ? fn : [fn]).forEach(function(x) {
      return global[x] = function(...args) {
        var e;
        try {
          return lib[x].apply(lib, args);
        } catch (error) {
          e = error;
          return abort(e);
        }
      };
    });
  };

  mergeStrings = function(toks, sep = '') {
    var reducer;
    reducer = function(xs, x) {
      var y;
      if (!isObject(x)) {
        x = `${x}`;
      }
      y = xs.pop();
      return xs.concat(isString(x) && isString(y) ? [[y, x].join(sep)] : [y, x]);
    };
    return toks.reduce(reducer, []).filter(function(x) {
      return (x != null) && x !== '';
    });
  };

  prependLines = function(x, prefix) {
    if (!(x && isString(x))) {
      return null;
    }
    return x.split(/\n/).map(function(x) {
      return x.trimRight();
    }).filter(identity).map(function(x) {
      return `${prefix}| ${x}`;
    }).join('\n');
  };

  rmCR = function(x = '') {
    var j, l, len, len1, lines, ref, ref1, v, w;
    lines = [];
    ref = x.split(/\r/);
    for (j = 0, len = ref.length; j < len; j++) {
      v = ref[j];
      if (v[0] === '\n') {
        v = v.slice(1);
      } else {
        lines.pop();
      }
      ref1 = v.split(/\n/);
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        w = ref1[l];
        lines.push(w);
      }
    }
    return lines.join('\n');
  };

  deepEqual = function(x, y) {
    var e;
    try {
      return !assert.deepEqual(x, y);
    } catch (error) {
      e = error;
      return false;
    }
  };

  // debug
  // crypto
  // values
  // collections
  // strings
  // decorators
  // types
  // assertions
  // files
  module.exports = {dbg, md5, md5File, md5Dir, md5Path, identity, deepEqual, assoc, conj, merge, deepMerge, hashMap, objKeys, objVals, reduceKv, selectKeys, notEmpty, invertObj, peek, getIn, split, mergeStrings, prependLines, rmCR, abortOnException, typeOf, isString, isArray, isObject, isBoolean, isDirectory, assertOk, assertObject, assertArray, fileExt, readFile};

}).call(this);

//# sourceMappingURL=fn.js.map
