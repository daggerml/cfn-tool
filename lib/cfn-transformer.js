// Generated by CoffeeScript 2.5.1
(function() {
  var CfnError, CfnTransformer, ResourceTypes, YamlTransformer, assert, fn, fs, indexOfClosingCurly, interpolateSub, log, os, parseKeyOpt, parseKeyOpts, path, topLevelResourceProperties, uuid, yaml,
    indexOf = [].indexOf;

  yaml = require('js-yaml');

  fs = require('fs');

  os = require('os');

  path = require('path');

  assert = require('assert');

  uuid = require('uuid');

  fn = require('./fn');

  log = require('./log');

  CfnError = require('./CfnError');

  YamlTransformer = require('./yaml-transformer');

  ({ResourceTypes} = require('./schema/CloudFormationResourceSpecification.json'));

  //=============================================================================#
  // Helper functions.                                                           #
  //=============================================================================#
  topLevelResourceProperties = ['Type', 'Condition', 'CreationPolicy', 'DeletionPolicy', 'DependsOn', 'Metadata', 'UpdatePolicy', 'UpdateReplacePolicy'];

  parseKeyOpt = function(opt) {
    var multi;
    if ((multi = opt.match(/^\[(.*)\]$/))) {
      return multi[1].split(',');
    } else {
      return opt;
    }
  };

  parseKeyOpts = function(opts) {
    return opts.reduce((function(xs, x) {
      var k, v;
      [k, v] = x.split('=');
      if (v == null) {
        v = k;
      }
      return fn.merge(xs, fn.hashMap(k, parseKeyOpt(v)));
    }), {});
  };

  indexOfClosingCurly = function(form) {
    var depth, i, j, ref1;
    depth = 0;
    for (i = j = 0, ref1 = form.length; (0 <= ref1 ? j < ref1 : j > ref1); i = 0 <= ref1 ? ++j : --j) {
      switch (form[i]) {
        case '{':
          depth++;
          break;
        case '}':
          if (!depth--) {
            return i;
          }
      }
    }
    return -1;
  };

  interpolateSub = function(form) {
    var i, ret;
    ret = [];
    while (true) {
      if (form.startsWith('${!')) {
        ret.push(form.slice(0, 2));
        form = form.slice(3);
      } else if (form.startsWith('${')) {
        i = indexOfClosingCurly(form.slice(2));
        assert.notEqual(i, -1, `no closing curly: ${JSON.stringify(form)}`);
        ret.push({
          Ref: form.slice(2, i + 2)
        });
        form = form.slice(i + 3);
      } else {
        if ((i = form.indexOf('${')) === -1) {
          ret.push(form);
          break;
        } else {
          ret.push(form.slice(0, i));
          form = form.slice(i);
        }
      }
    }
    return ret;
  };

  //=============================================================================#
  // AWS CLOUDFORMATION YAML TRANSFORMER BASE CLASS                              #
  //=============================================================================#
  CfnTransformer = class CfnTransformer extends YamlTransformer {
    constructor({
        ns,
        basedir,
        cache,
        opts: opts1,
        maps
      } = {}) {
      var base;
      super();
      this.ns = ns;
      this.basedir = basedir;
      this.cache = cache;
      this.opts = opts1;
      this.maps = maps;
      if (this.ns == null) {
        this.ns = uuid.v4();
      }
      if (this.opts == null) {
        this.opts = {};
      }
      if ((base = this.opts).s3prefix == null) {
        base.s3prefix = '';
      }
      if (this.cache == null) {
        this.cache = {};
      }
      if (this.basedir == null) {
        this.basedir = process.cwd();
      }
      this.template = null;
      this.needBucket = false;
      this.maps = JSON.parse(JSON.stringify(this.maps || {}));
      this.resourceMacros = [];
      this.bindstack = [];
      this.nested = [];
      //=========================================================================#
      // Redefine and extend built-in CloudFormation macros.                     #
      //=========================================================================#
      this.defmacro('Base64', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return {
          'Fn::Base64': form
        };
      });
      this.defmacro('GetAZs', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return {
          'Fn::GetAZs': form
        };
      });
      this.defmacro('ImportValue', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return {
          'Fn::ImportValue': form
        };
      });
      this.defmacro('GetAtt', (form) => {
        form = fn.isArray(form) && form.length === 1 ? form[0] : form;
        return {
          'Fn::GetAtt': fn.isString(form) ? fn.split(form, '.', 2) : form
        };
      });
      this.defmacro('RefAll', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return {
          'Fn::RefAll': form
        };
      });
      this.defmacro('Join', (form) => {
        var sep, toks, xs;
        [sep, toks] = form;
        switch ((xs = fn.mergeStrings(toks, sep)).length) {
          case 0:
            return '';
          case 1:
            return xs[0];
          default:
            return {
              'Fn::Join': [sep, xs]
            };
        }
      });
      this.defmacro('Condition', 'Condition', (form) => {
        return {
          Condition: fn.isArray(form) ? form[0] : form
        };
      });
      this.defmacro('Ref', 'Ref', (form) => {
        var bind, getin, ks, ref, refable, segs, walk;
        form = fn.assertString(fn.isArray(form) ? form[0] : form);
        segs = [ref, ...ks] = form.split('.');
        bind = fn.peek(this.bindstack);
        refable = (bind[ref] != null) || segs.length > 1;
        walk = (x) => {
          if (fn.isRef(x)) {
            return this.walk(x);
          } else {
            return x;
          }
        };
        getin = (m, ks) => {
          var ret;
          ret = ks.reduce((function(xs, x) {
            return walk(xs != null ? xs[x] : void 0);
          }), m);
          fn.assertOk(ret != null, `can't resolve: '${ks.join('.')}'`);
          return ret;
        };
        switch (false) {
          case !form.startsWith('$'):
            return {
              'Fn::Env': form.slice(1)
            };
          case !form.startsWith('%'):
            return {
              'Fn::Get': form.slice(1)
            };
          case !form.startsWith('@'):
            return {
              'Fn::Attr': form.slice(1)
            };
          case !form.startsWith('*'):
            return {
              'Fn::Var': form.slice(1)
            };
          case !refable:
            return getin(bind, segs);
          default:
            return {
              Ref: form
            };
        }
      });
      this.defmacro('Sub', (form) => {
        form = fn.isArray(form) && form.length === 1 ? form[0] : form;
        switch (fn.typeOf(form)) {
          case 'Str':
            return {
              'Fn::Join': ['', interpolateSub(form)]
            };
          default:
            return {
              'Fn::Sub': form
            };
        }
      });
      //=========================================================================#
      // Define special forms.                                                   #
      //=========================================================================#
      this.defspecial('Let', (form) => {
        form = fn.isArray(form) && form.length === 1 ? form[0] : form;
        if (fn.isArray(form)) {
          return this.withBindings(this.walk(form[0]), () => {
            return this.walk(form[1]);
          });
        } else {
          fn.merge(fn.peek(this.bindstack), fn.assertObject(form));
          return null;
        }
      });
      this.defspecial('Do', (form) => {
        return fn.assertArray(form).reduce(((xs, x) => {
          return this.walk(x);
        }), null);
      });
      this.defspecial('Mappings', (form = {}) => {
        this.maps = fn.deepMerge(this.maps, form);
        return {
          Mappings: this.maps
        };
      });
      //=========================================================================#
      // Define custom macros.                                                   #
      //=========================================================================#
      this.defmacro('Require', (form) => {
        var j, len, v;
        if (!fn.isArray(form)) {
          form = [form];
        }
        for (j = 0, len = form.length; j < len; j++) {
          v = form[j];
          require(path.resolve(v))(this, uuid.v4());
        }
        return null;
      });
      this.defmacro('Parameters', (form) => {
        return {
          Parameters: form.reduce(((xs, param) => {
            var name, opts;
            [name, ...opts] = param.split(/ +/);
            opts = fn.merge({
              Type: 'String'
            }, parseKeyOpts(opts));
            return fn.merge(xs, fn.hashMap(name, opts));
          }), {})
        };
      });
      this.defmacro('Return', (form) => {
        this.warn('!Return was deprecated in 4.2.0: use !Outputs instead');
        return {
          'Fn::Outputs': form
        };
      });
      this.defmacro('Outputs', (form) => {
        return {
          Outputs: fn.reduceKv(form, (xs, k, v) => {
            var name, opts, xport;
            [name, ...opts] = k.split(/ +/);
            xport = fn.notEmpty(opts = parseKeyOpts(opts)) ? (opts.Name ? opts.Name = this.walk({
              'Fn::Sub': opts.Name
            }) : void 0, {
              Export: opts
            }) : void 0;
            return fn.merge(xs, fn.hashMap(name, fn.merge({
              Value: v
            }, xport)));
          })
        };
      });
      this.defmacro('Resources', (form) => {
        var Type, body, id, m, opts, ret;
        ret = {};
        for (id in form) {
          body = form[id];
          [id, Type, ...opts] = id.split(/ +/);
          id = this.walk({
            'Fn::Sub': id
          });
          ret[id] = !Type ? (m = this.resourceMacros[body.Type]) ? m(body) : body : (body = fn.merge({Type}, parseKeyOpts(opts), {
            Properties: body
          }), (m = this.resourceMacros[Type]) ? m(body) : body);
        }
        return {
          Resources: ret
        };
      });
      this.defmacro('Attr', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return {
          'Fn::GetAtt': fn.split(form, '.', 2).map((x) => {
            return {
              'Fn::Sub': x
            };
          })
        };
      });
      this.defmacro('Get', (form) => {
        form = fn.isArray(form) && form.length === 1 ? form[0] : form;
        if (fn.isString(form)) {
          form = form.split('.');
        }
        return {
          'Fn::FindInMap': form.map((x) => {
            return {
              'Fn::Sub': x
            };
          })
        };
      });
      this.defmacro('Env', (form) => {
        var ret;
        form = fn.isArray(form) ? form[0] : form;
        ret = process.env[form];
        if (!ret) {
          throw new CfnError(`required environment variable not set: ${form}`);
        }
        return ret;
      });
      this.defmacro('Var', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return {
          'Fn::ImportValue': {
            'Fn::Sub': form
          }
        };
      });
      this.defmacro('Shell', (form) => {
        var env, vars;
        [vars = {}, form = ''] = (function() {
          switch (false) {
            case !(fn.isArray(form) && form.length === 2):
              return form;
            case !(fn.isArray(form) && form.length === 1):
              return [null].concat(form);
            case !fn.isString(form):
              return [null, form];
            default:
              throw new CfnError('!Shell: expected <string> or [<object>, <string>]');
          }
        })();
        env = Object.assign({}, process.env, vars);
        return this.withCache({
          shell: [this.ns, this.template, vars, form]
        }, () => {
          return (fn.execShell(form, {env}) || '').replace(/\n$/, '');
        });
      });
      this.defmacro('Js', (form) => {
        var vars;
        [vars = {}, form = ''] = (function() {
          switch (false) {
            case !(fn.isArray(form) && form.length === 2):
              return form;
            case !(fn.isArray(form) && form.length === 1):
              return [{}].concat(form);
            case !fn.isString(form):
              return [{}, form];
            default:
              throw new CfnError('!Js: expected <string> or [<object>, <string>]');
          }
        })();
        return this.withCache({
          js: [this.ns, this.template, vars, form]
        }, () => {
          var args, ret, vals;
          args = Object.keys(vars);
          vals = args.reduce((function(xs, x) {
            return xs.concat([`(${JSON.stringify(vars[x])})`]);
          }), []);
          form = `return (function(${args.join(',')}){${form}})(${vals.join(',')})`;
          ret = this.walk(new Function(form).call(this));
          if (ret == null) {
            throw new CfnError('!Js must not return null', form);
          }
          return ret;
        });
      });
      this.defmacro('Package', (form) => {
        return this.packageMacro(form);
      });
      this.defmacro('PackageURL', (form) => {
        var S3Bucket, S3Key;
        ({S3Bucket, S3Key} = this.packageMacro(form));
        return `https://s3.amazonaws.com/${S3Bucket}/${S3Key}`;
      });
      this.defmacro('PackageURI', (form) => {
        var S3Bucket, S3Key;
        ({S3Bucket, S3Key} = this.packageMacro(form));
        return `s3://${S3Bucket}/${S3Key}`;
      });
      this.defmacro('PackageTemplateURL', (form) => {
        var S3Bucket, S3Key;
        ({S3Bucket, S3Key} = this.packageMacro(form, {
          Parse: true
        }));
        return `https://s3.amazonaws.com/${S3Bucket}/${S3Key}`;
      });
      this.defmacro('YamlParse', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return yaml.safeLoad(form);
      });
      this.defmacro('YamlDump', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return yaml.safeDump(form);
      });
      this.defmacro('JsonParse', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return JSON.parse(form);
      });
      this.defmacro('JsonDump', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return JSON.stringify(form);
      });
      this.defmacro('File', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return fs.readFileSync(form);
      });
      this.defmacro('TemplateFile', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return yaml.safeLoad(this.transformTemplateFile(form));
      });
      this.defmacro('Merge', (form) => {
        return fn.merge.apply(null, form);
      });
      this.defmacro('DeepMerge', (form) => {
        return fn.deepMerge.apply(null, form);
      });
      this.defmacro('Tags', (form) => {
        var j, k, len, ref1, results;
        ref1 = Object.keys(form);
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          k = ref1[j];
          results.push({
            Key: k,
            Value: form[k]
          });
        }
        return results;
      });
      this.defresource('Stack', (form) => {
        var Parameters, Properties, Type, k, ref1, stackProps, v;
        Type = 'AWS::CloudFormation::Stack';
        Parameters = {};
        Properties = {Parameters};
        stackProps = Object.keys(ResourceTypes[Type].Properties);
        ref1 = form.Properties || {};
        for (k in ref1) {
          v = ref1[k];
          (indexOf.call(stackProps, k) >= 0 ? Properties : Parameters)[k] = v;
        }
        return fn.merge(form, {Type, Properties});
      });
    }

    macroexpand(form) {
      return this.walk(form);
    }

    withCache(key, f) {
      key = JSON.stringify(key);
      return (this.cache[key] || (this.cache[key] = [f()]))[0];
    }

    packageMacro(form, opts) {
      var CacheKey, Parse, Path;
      form = fn.isArray(form) ? form[0] : form;
      if (fn.isString(form)) {
        form = {
          Path: form
        };
      }
      form = Object.assign(form, opts);
      ({Path, CacheKey, Parse} = form);
      if (this.opts.dopackage) {
        this.needBucket = true;
        return this.withCache({
          package: [this.ns, this.userPath(Path), CacheKey, Parse]
        }, () => {
          return ((function() {
            switch (false) {
              case !fn.isDirectory(Path):
                return this.writeDir(Path, CacheKey);
              case !Parse:
                return this.writeTemplate(Path, CacheKey);
              default:
                return this.writeFile(Path, CacheKey);
            }
          }).call(this)).code;
        });
      } else {
        return {
          S3Bucket: 'example-bucket',
          S3Key: `${this.opts.s3prefix}example-key`
        };
      }
    }

    wrapError(e) {
      switch (false) {
        case e.name !== 'CfnError':
          return e;
        case e.name !== 'Error':
          return new CfnError(e.message);
        default:
          return new CfnError(`${e.name}: ${e.message}`);
      }
    }

    abort(e, {warn} = {}) {
      var aborting, body, errmsg, message;
      ({message, body, aborting} = e = this.wrapError(e));
      if (!aborting) {
        errmsg = [];
        if (message) {
          errmsg.push(message);
        }
        if (this.template) {
          errmsg.push(`in ${this.template}`);
        }
        if (this.keystack.length) {
          errmsg.push(`at ${this.keystack.join('/')}`);
        }
        e.message = errmsg.join('\n');
      }
      e.aborting = true;
      if (warn) {
        return log.warn(e.message);
      } else {
        throw e;
      }
    }

    verbose(message, body) {
      return log.verbose(message({body}));
    }

    info(message, body) {
      return log.info(message, {body});
    }

    warn(message, body) {
      return this.abort(new CfnError(message, body), {
        warn: true
      });
    }

    withCwd(dir, f) {
      var old;
      old = process.cwd();
      process.chdir(dir);
      try {
        return f();
      } finally {
        process.chdir(old);
      }
    }

    withKeyStack(ks, f) {
      var old, ret;
      [this.keystack, old] = [ks, this.keystack];
      ret = f();
      this.keystack = old;
      return ret;
    }

    bindings() {
      return Object.assign({}, fn.peek(this.bindstack));
    }

    options() {
      return Object.assign({}, this.opts);
    }

    withBindings(bindings, f) {
      var ret;
      this.bindstack.push(fn.merge({}, fn.peek(this.bindstack), fn.assertObject(bindings)));
      ret = f();
      this.bindstack.pop();
      return ret;
    }

    canonicalKeyPath() {
      return [this.template].concat(this.keystack);
    }

    canonicalHash(fileOrDir, key) {
      if (key) {
        return fn.md5(JSON.stringify([this.canonicalKeyPath(), key]));
      } else {
        return fn.md5Path(fileOrDir);
      }
    }

    writePaths(fileName, ext = '') {
      if (this.needBucket && !this.opts.s3bucket) {
        throw new CfnError("can't generate S3 URL: no S3 bucket configured");
      }
      fileName = `${fileName}${ext}`;
      return {
        nested: this.nested,
        tmpPath: this.tmpPath(fileName),
        code: {
          S3Bucket: this.opts.s3bucket,
          S3Key: `${this.opts.s3prefix}${fileName}`
        }
      };
    }

    writeText(text, ext, key, source = 'none') {
      var ret;
      ret = this.writePaths(fn.md5(key || text), ext);
      log.verbose(`wrote '${this.userPath(source)}' -> '${ret.tmpPath}'`);
      fs.writeFileSync(ret.tmpPath, text);
      return ret;
    }

    transformTemplateFile(file) {
      var ret, xformer;
      xformer = new this.constructor({ns: this.ns, basedir: this.basedir, cache: this.cache, opts: this.opts, maps: this.maps});
      ret = xformer.transformFile(file);
      this.nested = this.nested.concat(xformer.nested);
      return ret;
    }

    lint(file) {
      var cmd;
      log.verbose(`linting '${this.template}'`);
      cmd = `${this.opts.linter} ${file}`;
      return this.withCwd(this.basedir, (() => {
        return fn.tryExecRaw(cmd, 'lint error');
      }));
    }

    validate(file) {
      var cmd;
      log.verbose(`validating '${this.template}'`);
      cmd = `aws cloudformation validate-template --template-body "$(cat '${file}')"`;
      return fn.tryExecRaw(cmd, 'aws cloudformation validation error');
    }

    writeTemplate(file, key) {
      var e;
      try {
        this.template = this.userPath(file);
        return this.withKeyStack([], () => {
          var ret;
          ret = this.writeText(this.transformTemplateFile(file), fn.fileExt(file), key, file);
          if (this.opts.linter) {
            this.lint(ret.tmpPath);
          }
          if (this.opts.dovalidate) {
            this.validate(ret.tmpPath);
          }
          return ret;
        });
      } catch (error) {
        e = error;
        return this.abort(e);
      }
    }

    writeFile(file, key) {
      var ret;
      ret = this.writePaths(this.canonicalHash(file, key), fn.fileExt(file));
      log.verbose(`wrote '${this.userPath(file)}' -> '${ret.tmpPath}'`);
      fs.copyFileSync(file, ret.tmpPath);
      return ret;
    }

    writeDir(dir, key) {
      var ret, tmpZip;
      tmpZip = this.tmpPath(`${encodeURIComponent(this.userPath(dir))}.zip`);
      log.verbose(`packaging: '${dir}'`);
      fn.execShell(`zip -qr ${tmpZip} .`, {
        cwd: dir
      });
      ret = this.writePaths(this.canonicalHash(dir, key), '.zip');
      log.verbose(`wrote '${this.userPath(dir)}' -> '${ret.tmpPath}'`);
      fs.renameSync(tmpZip, ret.tmpPath);
      return ret;
    }

    userPath(file) {
      var ret;
      ret = path.relative(this.basedir, file);
      if (ret.startsWith('../')) {
        return path.resolve(ret);
      } else {
        return ret;
      }
    }

    tmpPath(name) {
      return path.join(this.opts.tmpdir, name);
    }

    pushFile(file, f) {
      var old, ret;
      this.nested.push(this.userPath(file));
      [old, this.template] = [this.template, this.userPath(file)];
      log.verbose(`transforming '${this.template}'`);
      ret = this.withCwd(path.dirname(file), (function() {
        return f(path.basename(file));
      }));
      this.template = old;
      return ret;
    }

    pushFileCaching(file, f) {
      return this.withCache({
        pushFileCaching: [this.ns, this.userPath(file)]
      }, () => {
        return this.pushFile(file, f);
      });
    }

    defresource(type, emit) {
      this.resourceMacros[type] = emit;
      return this;
    }

    transform(text) {
      this.bindstack = [{}];
      return super.transform(text);
    }

    transformFile(templateFile, doc) {
      var e;
      try {
        doc = doc || fs.readFileSync(templateFile).toString('utf-8');
        return this.pushFileCaching(templateFile, (file) => {
          return this.transform(doc);
        });
      } catch (error) {
        e = error;
        return this.abort(e);
      }
    }

  };

  module.exports = CfnTransformer;

}).call(this);

//# sourceMappingURL=cfn-transformer.js.map
