// Generated by CoffeeScript 2.5.1
(function() {
  var CfnError, CfnTransformer, ResourceTypes, YamlTransformer, assert, assertArray, assertObject, assoc, conj, crypto, deepMerge, fileExt, fs, getIn, hashMap, identity, indexOfClosingCurly, interpolateSub, isArray, isBoolean, isDirectory, isObject, isString, log, md5, md5Dir, md5File, md5Path, merge, mergeStrings, notEmpty, os, parseKeyOpt, parseKeyOpts, path, peek, prependLines, readFile, reduceKv, spawnSync, split, topLevelResourceProperties, typeOf, yaml,
    indexOf = [].indexOf;

  yaml = require('js-yaml');

  fs = require('fs');

  os = require('os');

  path = require('path');

  assert = require('assert');

  crypto = require('crypto');

  ({spawnSync} = require('child_process'));

  log = require('./log');

  CfnError = require('./CfnError');

  YamlTransformer = require('./yaml-transformer');

  ({ResourceTypes} = require('./schema/CloudFormationResourceSpecification.json'));

  //=============================================================================#
  // Helper functions.                                                           #
  //=============================================================================#
  topLevelResourceProperties = ['Type', 'Condition', 'CreationPolicy', 'DeletionPolicy', 'DependsOn', 'Metadata', 'UpdatePolicy', 'UpdateReplacePolicy'];

  identity = function(x) {
    return x;
  };

  assoc = function(xs, k, v) {
    xs[k] = v;
    return xs;
  };

  conj = function(xs, x) {
    xs.push(x);
    return xs;
  };

  readFile = function(file) {
    return fs.readFileSync(file).toString('utf-8');
  };

  typeOf = function(thing) {
    return Object.prototype.toString.call(thing).slice(8, -1);
  };

  fileExt = function(file) {
    var e;
    if ((e = split(path.basename(file), '.', 2)[1]) != null) {
      return `.${e}`;
    }
  };

  merge = function(...args) {
    return Object.assign.apply(null, args);
  };

  deepMerge = function(...args) {
    var dm;
    dm = function(x, y) {
      var k, ret, v;
      if (!(isObject(x) && isObject(y))) {
        return y;
      } else {
        ret = Object.assign({}, x);
        for (k in y) {
          v = y[k];
          ret[k] = dm(x[k], v);
        }
        return ret;
      }
    };
    return args.reduce((function(xs, x) {
      return dm(xs, x);
    }), {});
  };

  hashMap = function(...args) {
    var i, j, ref1, ret;
    ret = {};
    for (i = j = 0, ref1 = args.length / 2; (0 <= ref1 ? j < ref1 : j > ref1); i = 0 <= ref1 ? ++j : --j) {
      ret[args[2 * i]] = args[2 * i + 1];
    }
    return ret;
  };

  isDirectory = function(file) {
    return fs.statSync(file).isDirectory();
  };

  reduceKv = function(map, f) {
    return Object.keys(map).reduce((function(xs, k) {
      return f(xs, k, map[k]);
    }), {});
  };

  notEmpty = function(map) {
    return Object.keys(map || {}).length > 0;
  };

  md5 = function(data) {
    return crypto.createHash("md5").update(data).digest("hex");
  };

  md5File = function(filePath) {
    return md5(fs.readFileSync(filePath));
  };

  md5Dir = function(dirPath) {
    var add2tree, origDir;
    origDir = process.cwd();
    try {
      process.chdir(dirPath);
      add2tree = function(tree, path) {
        return assoc(tree, path, md5Path(path));
      };
      return md5(JSON.stringify(fs.readdirSync('.').sort().reduce(add2tree, {})));
    } finally {
      process.chdir(origDir);
    }
  };

  md5Path = function(path) {
    return (isDirectory(path) ? md5Dir : md5File)(path);
  };

  peek = function(ary) {
    return ary[ary.length - 1];
  };

  getIn = function(obj, ks) {
    return ks.reduce((function(xs, x) {
      return xs[x];
    }), obj);
  };

  split = function(str, sep, count = 2e308) {
    var n, toks;
    toks = str.split(sep);
    n = Math.min(toks.length, count) - 1;
    return toks.slice(0, n).concat(toks.slice(n).join(sep));
  };

  isString = function(x) {
    return typeOf(x) === 'String';
  };

  isArray = function(x) {
    return typeOf(x) === 'Array';
  };

  isObject = function(x) {
    return typeOf(x) === 'Object';
  };

  isBoolean = function(x) {
    return typeOf(x) === 'Boolean';
  };

  assertObject = function(thing) {
    var ref1;
    assert.ok((ref1 = typeOf(thing)) === 'Object' || ref1 === 'Undefined' || ref1 === 'Null', `expected an Object, got ${JSON.stringify(thing)}`);
    return thing;
  };

  assertArray = function(thing) {
    assert.ok(isArray(thing), `expected an Array, got ${JSON.stringify(thing)}`);
    return thing;
  };

  parseKeyOpt = function(opt) {
    var multi;
    if ((multi = opt.match(/^\[(.*)\]$/))) {
      return multi[1].split(',');
    } else {
      return opt;
    }
  };

  parseKeyOpts = function(opts) {
    return opts.reduce((function(xs, x) {
      var k, v;
      [k, v] = x.split('=');
      if (v == null) {
        v = k;
      }
      return merge(xs, hashMap(k, parseKeyOpt(v)));
    }), {});
  };

  mergeStrings = function(toks, sep = '') {
    var reducer;
    reducer = function(xs, x) {
      var y;
      if (!isObject(x)) {
        x = `${x}`;
      }
      y = xs.pop();
      return xs.concat(isString(x) && isString(y) ? [[y, x].join(sep)] : [y, x]);
    };
    return toks.reduce(reducer, []).filter(function(x) {
      return (x != null) && x !== '';
    });
  };

  prependLines = function(x, prefix) {
    if (!(x && isString(x))) {
      return null;
    }
    return x.split(/\n/).map(function(x) {
      return x.trimRight();
    }).filter(identity).map(function(x) {
      return `${prefix}| ${x}`;
    }).join('\n');
  };

  indexOfClosingCurly = function(form) {
    var depth, i, j, ref1;
    depth = 0;
    for (i = j = 0, ref1 = form.length; (0 <= ref1 ? j < ref1 : j > ref1); i = 0 <= ref1 ? ++j : --j) {
      switch (form[i]) {
        case '{':
          depth++;
          break;
        case '}':
          if (!depth--) {
            return i;
          }
      }
    }
    return -1;
  };

  interpolateSub = function(form) {
    var i, ret;
    ret = [];
    while (true) {
      if (form.startsWith('${!')) {
        ret.push(form.slice(0, 3));
        form = form.slice(3);
      } else if (form.startsWith('${')) {
        i = indexOfClosingCurly(form.slice(2));
        assert.notEqual(i, -1, `no closing curly: ${JSON.stringify(form)}`);
        ret.push({
          Ref: form.slice(2, i + 2)
        });
        form = form.slice(i + 3);
      } else {
        if ((i = form.indexOf('${')) === -1) {
          ret.push(form);
          break;
        } else {
          ret.push(form.slice(0, i));
          form = form.slice(i);
        }
      }
    }
    return ret;
  };

  //=============================================================================#
  // AWS CLOUDFORMATION YAML TRANSFORMER BASE CLASS                              #
  //=============================================================================#
  CfnTransformer = class CfnTransformer extends YamlTransformer {
    constructor({basedir, tmpdir, cache, s3bucket, s3prefix, verbose, linter, dolint, dovalidate, dopackage} = {}) {
      var ref1;
      super();
      this.basedir = basedir;
      this.tmpdir = tmpdir;
      this.cache = cache;
      this.s3bucket = s3bucket;
      this.s3prefix = s3prefix;
      this.verbose = verbose;
      this.linter = linter;
      this.dolint = dolint;
      this.dovalidate = dovalidate;
      this.dopackage = dopackage;
      if (this.cache == null) {
        this.cache = {};
      }
      if (this.basedir == null) {
        this.basedir = process.cwd();
      }
      if (this.s3prefix == null) {
        this.s3prefix = '';
      }
      this.tmpdir = path.resolve((ref1 = this.tmpdir) != null ? ref1 : fs.mkdtempSync(`${os.tmpdir()}/`));
      this.template = null;
      this.resourceMacros = [];
      this.bindstack = [];
      this.nested = [];
      //=========================================================================#
      // Redefine and extend built-in CloudFormation macros.                     #
      //=========================================================================#
      this.defmacro('Base64', (form) => {
        form = isArray(form) ? form[0] : form;
        return {
          'Fn::Base64': form
        };
      });
      this.defmacro('GetAZs', (form) => {
        form = isArray(form) ? form[0] : form;
        return {
          'Fn::GetAZs': form
        };
      });
      this.defmacro('ImportValue', (form) => {
        form = isArray(form) ? form[0] : form;
        return {
          'Fn::ImportValue': form
        };
      });
      this.defmacro('GetAtt', (form) => {
        form = isArray(form) && form.length === 1 ? form[0] : form;
        return {
          'Fn::GetAtt': isString(form) ? split(form, '.', 2) : form
        };
      });
      this.defmacro('RefAll', (form) => {
        form = isArray(form) ? form[0] : form;
        return {
          'Fn::RefAll': form
        };
      });
      this.defmacro('Join', (form) => {
        var sep, toks, xs;
        [sep, toks] = form;
        switch ((xs = mergeStrings(toks, sep)).length) {
          case 0:
            return '';
          case 1:
            return xs[0];
          default:
            return {
              'Fn::Join': [sep, xs]
            };
        }
      });
      this.defmacro('Condition', 'Condition', (form) => {
        return {
          Condition: isArray(form) ? form[0] : form
        };
      });
      this.defmacro('Ref', 'Ref', (form) => {
        var ks, ref;
        form = isArray(form) ? form[0] : form;
        if (isString(form)) {
          [ref, ...ks] = form.split('.');
          switch (false) {
            case !form.startsWith('$'):
              return {
                'Fn::Env': form.slice(1)
              };
            case !form.startsWith('%'):
              return {
                'Fn::Get': form.slice(1)
              };
            case !form.startsWith('@'):
              return {
                'Fn::Attr': form.slice(1)
              };
            case peek(this.bindstack)[ref] == null:
              return getIn(peek(this.bindstack)[ref], ks);
            default:
              return {
                Ref: form
              };
          }
        } else {
          return form;
        }
      });
      this.defmacro('Sub', (form) => {
        form = isArray(form) && form.length === 1 ? form[0] : form;
        switch (typeOf(form)) {
          case 'String':
            return {
              'Fn::Join': ['', interpolateSub(form)]
            };
          default:
            return {
              'Fn::Sub': form
            };
        }
      });
      //=========================================================================#
      // Define special forms.                                                   #
      //=========================================================================#
      this.defspecial('Let', (form) => {
        form = isArray(form) && form.length === 1 ? form[0] : form;
        if (isArray(form)) {
          return this.withBindings(this.walk(form[0]), () => {
            return this.walk(form[1]);
          });
        } else {
          merge(peek(this.bindstack), assertObject(this.walk(form)));
          return null;
        }
      });
      this.defspecial('Do', (form) => {
        return assertArray(form).reduce(((xs, x) => {
          return this.walk(x);
        }), null);
      });
      //=========================================================================#
      // Define custom macros.                                                   #
      //=========================================================================#
      this.defmacro('Require', (form) => {
        var j, len, v;
        if (!isArray(form)) {
          form = [form];
        }
        for (j = 0, len = form.length; j < len; j++) {
          v = form[j];
          require(path.resolve(v))(this);
        }
        return null;
      });
      this.defmacro('Parameters', (form) => {
        return {
          Parameters: form.reduce(((xs, param) => {
            var name, opts;
            [name, ...opts] = param.split(/ +/);
            opts = merge({
              Type: 'String'
            }, parseKeyOpts(opts));
            return merge(xs, hashMap(name, opts));
          }), {})
        };
      });
      this.defmacro('Return', (form) => {
        return {
          Outputs: reduceKv(form, (xs, k, v) => {
            var name, opts, xport;
            [name, ...opts] = k.split(/ +/);
            xport = notEmpty(opts = parseKeyOpts(opts)) ? (opts.Name ? opts.Name = this.walk({
              'Fn::Sub': opts.Name
            }) : void 0, {
              Export: opts
            }) : void 0;
            return merge(xs, hashMap(name, merge({
              Value: v
            }, xport)));
          })
        };
      });
      this.defmacro('Resources', (form) => {
        var Type, body, id, m, opts, ret;
        ret = {};
        for (id in form) {
          body = form[id];
          [id, Type, ...opts] = id.split(/ +/);
          id = this.walk({
            'Fn::Sub': id
          });
          ret[id] = !Type ? (m = this.resourceMacros[body.Type]) ? m(body) : body : (body = merge({Type}, parseKeyOpts(opts), {
            Properties: body
          }), (m = this.resourceMacros[Type]) ? m(body) : body);
        }
        return {
          Resources: ret
        };
      });
      this.defmacro('Attr', (form) => {
        form = isArray(form) ? form[0] : form;
        return {
          'Fn::GetAtt': split(form, '.', 2).map((x) => {
            return {
              'Fn::Sub': x
            };
          })
        };
      });
      this.defmacro('Get', (form) => {
        form = isArray(form) && form.length === 1 ? form[0] : form;
        if (isString(form)) {
          form = form.split('.');
        }
        return {
          'Fn::FindInMap': form.map((x) => {
            return {
              'Fn::Sub': x
            };
          })
        };
      });
      this.defmacro('Env', (form) => {
        var ret;
        form = isArray(form) ? form[0] : form;
        ret = process.env[form];
        if (!ret) {
          throw new CfnError(`required environment variable not set: ${form}`);
        }
        return ret;
      });
      this.defmacro('Var', (form) => {
        form = isArray(form) ? form[0] : form;
        return {
          'Fn::ImportValue': {
            'Fn::Sub': form
          }
        };
      });
      this.defmacro('Shell', (form) => {
        var key;
        form = isArray(form) ? form[0] : form;
        key = JSON.stringify({
          shell: [this.template, form]
        });
        if (this.cache[key] == null) {
          this.cache[key] = (this.execShell(form) || '').replace(/\n$/, '');
        }
        return this.cache[key];
      });
      this.defmacro('Package', (form) => {
        return this.packageMacro(form);
      });
      this.defmacro('PackageURL', (form) => {
        var S3Bucket, S3Key;
        ({S3Bucket, S3Key} = this.packageMacro(form));
        return `https://s3.amazonaws.com/${S3Bucket}/${S3Key}`;
      });
      this.defmacro('PackageURI', (form) => {
        var S3Bucket, S3Key;
        ({S3Bucket, S3Key} = this.packageMacro(form));
        return `s3://${S3Bucket}/${S3Key}`;
      });
      this.defmacro('PackageTemplateURL', (form) => {
        var S3Bucket, S3Key;
        ({S3Bucket, S3Key} = this.packageMacro(form, {
          Parse: true
        }));
        return `https://s3.amazonaws.com/${S3Bucket}/${S3Key}`;
      });
      this.defmacro('YamlParse', (form) => {
        form = isArray(form) ? form[0] : form;
        return yaml.safeLoad(form);
      });
      this.defmacro('YamlDump', (form) => {
        form = isArray(form) ? form[0] : form;
        return yaml.safeDump(form);
      });
      this.defmacro('JsonParse', (form) => {
        form = isArray(form) ? form[0] : form;
        return JSON.parse(form);
      });
      this.defmacro('JsonDump', (form) => {
        form = isArray(form) ? form[0] : form;
        return JSON.stringify(form);
      });
      this.defmacro('File', (form) => {
        form = isArray(form) ? form[0] : form;
        return fs.readFileSync(form);
      });
      this.defmacro('TemplateFile', (form) => {
        form = isArray(form) ? form[0] : form;
        return yaml.safeLoad(this.transformTemplateFile(form));
      });
      this.defmacro('Merge', (form) => {
        return merge.apply(null, form);
      });
      this.defmacro('DeepMerge', (form) => {
        return deepMerge.apply(null, form);
      });
      this.defmacro('Tags', (form) => {
        var j, k, len, ref2, results;
        ref2 = Object.keys(form);
        results = [];
        for (j = 0, len = ref2.length; j < len; j++) {
          k = ref2[j];
          results.push({
            Key: k,
            Value: form[k]
          });
        }
        return results;
      });
      this.defresource('Stack', (form) => {
        var Parameters, Properties, Type, k, ref2, stackProps, v;
        Type = 'AWS::CloudFormation::Stack';
        Parameters = {};
        Properties = {Parameters};
        stackProps = Object.keys(ResourceTypes[Type].Properties);
        ref2 = form.Properties || {};
        for (k in ref2) {
          v = ref2[k];
          (indexOf.call(stackProps, k) >= 0 ? Properties : Parameters)[k] = v;
        }
        return merge(form, {Type, Properties});
      });
    }

    packageMacro(form, opts) {
      var CacheKey, Parse, Path, key;
      form = isArray(form) ? form[0] : form;
      if (isString(form)) {
        form = {
          Path: form
        };
      }
      form = Object.assign(form, opts);
      ({Path, CacheKey, Parse} = form);
      if (this.dopackage) {
        key = JSON.stringify({
          package: [this.userPath(Path), CacheKey, Parse]
        });
        if (this.cache[key] == null) {
          this.cache[key] = (isDirectory(Path) ? this.writeDir(Path, CacheKey) : Parse ? this.writeTemplate(Path, CacheKey) : this.writeFile(Path, CacheKey)).code;
        }
        return this.cache[key];
      } else {
        return {
          S3Bucket: 'example-bucket',
          S3Key: `${this.s3prefix}example-key`
        };
      }
    }

    wrapError(e) {
      switch (false) {
        case e.name !== 'CfnError':
          return e;
        case e.name !== 'Error':
          return new CfnError(e.message);
        default:
          return new CfnError(`${e.name}: ${e.message}`);
      }
    }

    abort(e) {
      var aborting, body, errmsg, message;
      ({message, body, aborting} = e = this.wrapError(e));
      if (!aborting) {
        errmsg = [];
        if (message) {
          errmsg.push(message);
        }
        if (this.template) {
          errmsg.push(`in ${this.template}`);
        }
        if (this.keystack.length) {
          errmsg.push(`at ${this.keystack.join('/')}`);
        }
        e.message = errmsg.join('\n');
      }
      e.aborting = true;
      throw e;
    }

    handleShell(cmd, res, raw) {
      var ref1, ref2, stderr, stdout;
      cmd = prependLines(cmd, 'cmd');
      stdout = (ref1 = res.stdout) != null ? ref1.toString('utf-8') : void 0;
      stderr = (ref2 = res.stderr) != null ? ref2.toString('utf-8') : void 0;
      res.out = prependLines(stdout, 'out');
      res.err = prependLines(stderr, 'err');
      res.all = [res.out, res.err].filter(identity).join('\n');
      if (raw) {
        return res;
      } else {
        if (res.status === 0) {
          log.verbose("bash: status 0", {
            body: `${cmd}\n${res.all}`
          });
          return stdout;
        } else {
          throw new CfnError(`bash: exit status ${res.status}`, `${cmd}\n${res.all}`);
        }
      }
    }

    execShell(cmd, opts, raw = false) {
      var res;
      res = spawnSync(cmd, merge({
        stdio: 'pipe',
        shell: '/bin/bash'
      }, opts));
      return this.handleShell(cmd, res, raw);
    }

    execShellArgs(cmd, args, opts, raw = false) {
      var res;
      res = spawnSync(cmd, args, merge({
        stdio: 'pipe',
        shell: '/bin/bash'
      }, opts));
      return this.handleShell(cmd, res, raw);
    }

    withCwd(dir, f) {
      var old;
      old = process.cwd();
      process.chdir(dir);
      try {
        return f();
      } finally {
        process.chdir(old);
      }
    }

    withKeyStack(ks, f) {
      var old, ret;
      [this.keystack, old] = [ks, this.keystack];
      ret = f();
      this.keystack = old;
      return ret;
    }

    withBindings(bindings, f) {
      var ret;
      this.bindstack.push(merge({}, peek(this.bindstack), assertObject(bindings)));
      ret = f();
      this.bindstack.pop();
      return ret;
    }

    canonicalKeyPath() {
      return [this.template].concat(this.keystack);
    }

    canonicalHash(fileOrDir, key) {
      if (key) {
        return md5(JSON.stringify([this.canonicalKeyPath(), key]));
      } else {
        return md5Path(fileOrDir);
      }
    }

    writePaths(fileName, ext = '') {
      if (!this.s3bucket) {
        throw new CfnError("can't generate S3 URL: no S3 bucket configured");
      }
      fileName = `${fileName}${ext}`;
      return {
        nested: this.nested,
        tmpPath: this.tmpPath(fileName),
        code: {
          S3Bucket: this.s3bucket,
          S3Key: `${this.s3prefix}${fileName}`
        }
      };
    }

    writeText(text, ext, key, source = 'none') {
      var ret;
      ret = this.writePaths(md5(key || text), ext);
      log.verbose(`wrote ${this.userPath(source)} -> ${ret.tmpPath}`);
      fs.writeFileSync(ret.tmpPath, text);
      return ret;
    }

    transformTemplateFile(file) {
      var ret, xformer;
      xformer = new this.constructor({basedir: this.basedir, tmpdir: this.tmpdir, cache: this.cache, s3bucket: this.s3bucket, s3prefix: this.s3prefix, verbose: this.verbose, linter: this.linter, dolint: this.dolint, dovalidate: this.dovalidate, dopackage: this.dopackage});
      ret = xformer.transformFile(file);
      this.nested = this.nested.concat(xformer.nested);
      return ret;
    }

    tryExecRaw(cmd, msg) {
      var res;
      res = this.execShell(cmd, null, true);
      cmd = prependLines(cmd, 'cmd');
      if (res.status === 0) {
        return log.verbose("bash: status 0", {
          body: `${cmd}\n${res.all}`
        });
      } else {
        log.verbose(`bash: exit status ${res.status}`, {
          body: cmd
        });
        throw new CfnError(msg, res.all);
      }
    }

    lint(file) {
      var cmd;
      log.verbose(`linting ${this.template}`);
      cmd = `${this.linter} ${file}`;
      return this.withCwd(this.basedir, (() => {
        return this.tryExecRaw(cmd, 'lint error');
      }));
    }

    validate(file) {
      var cmd;
      log.verbose(`validating ${this.template}`);
      cmd = `aws cloudformation validate-template --template-body "$(cat '${file}')"`;
      return this.tryExecRaw(cmd, 'aws cloudformation validation error');
    }

    writeTemplate(file, key) {
      var e;
      try {
        this.template = this.userPath(file);
        return this.withKeyStack([], () => {
          var ret;
          ret = this.writeText(this.transformTemplateFile(file), fileExt(file), key, file);
          log.verbose(`wrote ${this.userPath(file)} -> ${ret.tmpPath}`);
          if (this.linter && this.dolint) {
            this.lint(ret.tmpPath);
          }
          if (this.dovalidate) {
            this.validate(ret.tmpPath);
          }
          return ret;
        });
      } catch (error) {
        e = error;
        return this.abort(e);
      }
    }

    writeFile(file, key) {
      var ret;
      ret = this.writePaths(this.canonicalHash(file, key), fileExt(file));
      log.verbose(`wrote ${this.userPath(file)} -> ${ret.tmpPath}`);
      fs.copyFileSync(file, ret.tmpPath);
      return ret;
    }

    writeDir(dir, key) {
      var ret, tmpZip;
      tmpZip = this.tmpPath(`${encodeURIComponent(this.userPath(dir))}.zip`);
      log.verbose(`packaging: ${dir}`);
      this.execShell(`zip -qr ${tmpZip} .`, {
        cwd: dir
      });
      ret = this.writePaths(this.canonicalHash(dir, key), '.zip');
      log.verbose(`wrote ${this.userPath(dir)} -> ${ret.tmpPath}`);
      fs.renameSync(tmpZip, ret.tmpPath);
      return ret;
    }

    userPath(file) {
      return path.relative(this.basedir, file);
    }

    tmpPath(name) {
      return path.join(this.tmpdir, name);
    }

    pushFile(file, f) {
      var old, ret;
      this.nested.push(this.userPath(file));
      [old, this.template] = [this.template, this.userPath(file)];
      log.verbose(`transforming ${this.template}`);
      ret = this.withCwd(path.dirname(file), (function() {
        return f(path.basename(file));
      }));
      this.template = old;
      return ret;
    }

    pushFileCaching(file, f) {
      var key;
      key = JSON.stringify({
        pushFileCaching: this.userPath(file)
      });
      if (!this.cache[key]) {
        this.cache[key] = this.pushFile(file, f);
      }
      return this.cache[key];
    }

    defresource(type, emit) {
      this.resourceMacros[type] = emit;
      return this;
    }

    transform(text) {
      this.bindstack = [{}];
      return super.transform(text);
    }

    transformFile(templateFile, doc) {
      var e;
      try {
        doc = doc || fs.readFileSync(templateFile).toString('utf-8');
        return this.pushFileCaching(templateFile, (file) => {
          return this.transform(doc);
        });
      } catch (error) {
        e = error;
        return this.abort(e);
      }
    }

  };

  module.exports = CfnTransformer;

}).call(this);
