// Generated by CoffeeScript 2.5.1
(function() {
  var CfnError, CfnModule, CfnTransformer, ResourceTypes, YamlTransformer, assert, clone, fn, fs, indexOfClosingCurly, interpolateSub, log, os, parseKeyOpt, parseKeyOpts, path, topLevelResourceProperties, uuid, yaml,
    indexOf = [].indexOf;

  yaml = require('js-yaml');

  fs = require('fs');

  os = require('os');

  path = require('path');

  assert = require('assert');

  uuid = require('uuid');

  fn = require('./fn');

  log = require('./log');

  CfnError = require('./CfnError');

  YamlTransformer = require('./yaml-transformer');

  ({ResourceTypes} = require('./schema/CloudFormationResourceSpecification.json'));

  //=============================================================================#
  // Helper functions.                                                           #
  //=============================================================================#
  topLevelResourceProperties = ['Type', 'Condition', 'CreationPolicy', 'DeletionPolicy', 'DependsOn', 'Metadata', 'UpdatePolicy', 'UpdateReplacePolicy'];

  parseKeyOpt = function(opt) {
    var multi, ret;
    ret = (multi = opt.match(/^\[(.*)\]$/)) ? multi[1].split(',') : opt;
    if (fn.isArray(ret)) {
      return ret.map(function(x) {
        return {
          'Fn::Sub': x
        };
      });
    } else {
      return {
        'Fn::Sub': ret
      };
    }
  };

  parseKeyOpts = function(opts) {
    return opts.reduce((function(xs, x) {
      var k, v;
      [k, v] = x.split('=');
      if (v == null) {
        v = k;
      }
      return fn.merge(xs, fn.hashMap(k, parseKeyOpt(v)));
    }), {});
  };

  indexOfClosingCurly = function(form) {
    var depth, i, j, ref1;
    depth = 0;
    for (i = j = 0, ref1 = form.length; (0 <= ref1 ? j < ref1 : j > ref1); i = 0 <= ref1 ? ++j : --j) {
      switch (form[i]) {
        case '{':
          depth++;
          break;
        case '}':
          if (!depth--) {
            return i;
          }
      }
    }
    return -1;
  };

  interpolateSub = function(form) {
    var i, ret;
    ret = [];
    while (true) {
      if (form.startsWith('${!')) {
        ret.push(form.slice(0, 2));
        form = form.slice(3);
      } else if (form.startsWith('${')) {
        i = indexOfClosingCurly(form.slice(2));
        assert.notEqual(i, -1, `no closing curly: ${JSON.stringify(form)}`);
        ret.push({
          Ref: form.slice(2, i + 2)
        });
        form = form.slice(i + 3);
      } else {
        if ((i = form.indexOf('${')) === -1) {
          ret.push(form);
          break;
        } else {
          ret.push(form.slice(0, i));
          form = form.slice(i);
        }
      }
    }
    return ret;
  };

  clone = function(jsonable) {
    return JSON.parse(JSON.stringify(jsonable));
  };

  //=============================================================================#
  // TRANSFORMER CLASS FOR USE IN REQUIRED MACRO MODULES                         #
  //=============================================================================#
  CfnModule = class CfnModule {
    constructor(transformer, id1) {
      var base, name1;
      this.transformer = transformer;
      this.id = id1;
      if (this.id) {
        if ((base = this.transformer.state)[name1 = this.id] == null) {
          base[name1] = {};
        }
      }
    }

    bindings() {
      return clone(fn.peek(this.transformer.bindstack));
    }

    options() {
      return clone(this.transformer.opts);
    }

    state() {
      fn.assertOk(this.id, 'defmacro: only allowed in !Require modules');
      return this.transformer.state[this.id];
    }

    defmacro(name, ...args) {
      args[args.length - 1] = args[args.length - 1].bind(this);
      return this.transformer.defmacro.apply(this.transformer, [name].concat(args));
    }

    defresource(name, long, f) {
      args[args.length - 1] = args[args.length - 1].bind(this);
      return this.transformer.defresource.apply(this.transformer, [name].concat(args));
    }

    macroexpand(form) {
      return this.transformer.walk(form);
    }

    md5(text) {
      return fn.md5(text);
    }

    tmpPath(name) {
      return this.transformer.tmpPath(name);
    }

    userPath(path) {
      return this.transformer.userPath(path);
    }

    error(message, body) {
      return this.transformer.abort(new CfnError(message, body));
    }

    warn(message, body) {
      return log.warn(this.transformer.atLocation(message), {body});
    }

    info(message, body) {
      return log.info(message, {body});
    }

    verbose(message, body) {
      return log.verbose(message, {body});
    }

    withBindings(bindings, f) {
      return this.transformer.withBindings(bindings, f);
    }

    withCache(key, f) {
      fn.assertOk(this.id, 'withCache: only allowed in !Require modules');
      return this.transformer.withCache({
        module: this.id,
        key
      }, f);
    }

    withCwd(dir, f) {
      return this.transformer.withCwd(dir, f);
    }

  };

  //=============================================================================#
  // AWS CLOUDFORMATION YAML TRANSFORMER BASE CLASS                              #
  //=============================================================================#
  CfnTransformer = class CfnTransformer extends YamlTransformer {
    constructor({
        ns,
        basedir,
        cache,
        opts: opts1,
        maps,
        globals,
        state
      } = {}) {
      var base;
      super();
      this.ns = ns;
      this.basedir = basedir;
      this.cache = cache;
      this.opts = opts1;
      this.maps = maps;
      this.globals = globals;
      this.state = state;
      if (this.ns == null) {
        this.ns = uuid.v4();
      }
      if (this.opts == null) {
        this.opts = {};
      }
      if ((base = this.opts).s3prefix == null) {
        base.s3prefix = '';
      }
      if (this.cache == null) {
        this.cache = {};
      }
      if (this.basedir == null) {
        this.basedir = process.cwd();
      }
      this.template = null;
      this.needBucket = false;
      this.maps = clone(this.maps || {});
      this.globals = clone(this.globals || {});
      this.state = clone(this.state || {});
      this.resourceMacros = [];
      this.bindstack = [this.globals];
      this.nested = [];
      //=========================================================================#
      // Redefine and extend built-in CloudFormation macros.                     #
      //=========================================================================#
      this.defmacro('Base64', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return {
          'Fn::Base64': form
        };
      });
      this.defmacro('GetAZs', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return {
          'Fn::GetAZs': form
        };
      });
      this.defmacro('ImportValue', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return {
          'Fn::ImportValue': form
        };
      });
      this.defmacro('GetAtt', (form) => {
        form = fn.isArray(form) && form.length === 1 ? form[0] : form;
        return {
          'Fn::GetAtt': fn.isString(form) ? fn.split(form, '.', 2) : form
        };
      });
      this.defmacro('RefAll', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return {
          'Fn::RefAll': form
        };
      });
      this.defmacro('Join', (form) => {
        var sep, toks, xs;
        [sep, toks] = form;
        switch ((xs = fn.mergeStrings(toks, sep)).length) {
          case 0:
            return '';
          case 1:
            return xs[0];
          default:
            return {
              'Fn::Join': [sep, xs]
            };
        }
      });
      this.defmacro('Condition', 'Condition', (form) => {
        return {
          Condition: fn.isArray(form) ? form[0] : form
        };
      });
      this.defmacro('Ref', 'Ref', (form) => {
        var bind, getin, ks, ref, refable, segs;
        form = fn.assertString(fn.isArray(form) ? form[0] : form);
        segs = [ref, ...ks] = form.split('.');
        bind = fn.peek(this.bindstack);
        refable = (bind[ref] != null) || segs.length > 1;
        getin = (m, ks) => {
          var ret;
          ret = ks.reduce(((xs, x) => {
            return this.walk(xs != null ? xs[x] : void 0);
          }), m);
          fn.assertOk(ret != null, `can't resolve: '${ks.join('.')}'`);
          return ret;
        };
        switch (false) {
          case !form.startsWith('$'):
            return {
              'Fn::Env': form.slice(1)
            };
          case !form.startsWith('%'):
            return {
              'Fn::Get': form.slice(1)
            };
          case !form.startsWith('@'):
            return {
              'Fn::Attr': form.slice(1)
            };
          case !form.startsWith('*'):
            return {
              'Fn::Var': form.slice(1)
            };
          case !refable:
            return getin(bind, segs);
          default:
            return {
              Ref: form
            };
        }
      });
      this.defmacro('Sub', (form) => {
        form = (function() {
          switch (false) {
            case !fn.isString(form):
              return [form, {}];
            case !(fn.isArray(form) && form.length === 1):
              return form.concat([{}]);
            case !(fn.isArray(form) && form.length === 2):
              return form;
            default:
              throw new CfnError(`invalid type: ${JSON.stringify(form)}`);
          }
        })();
        return {
          'Fn::Let': [
            form[1],
            {
              'Fn::Join': ['',
            interpolateSub(form[0])]
            }
          ]
        };
      });
      //=========================================================================#
      // Define special forms.                                                   #
      //=========================================================================#
      this.defspecial('Let', (form) => {
        form = fn.isArray(form) && form.length === 1 ? form[0] : form;
        if (fn.isArray(form)) {
          return this.withBindings(this.walk(form[0]), () => {
            return this.walk(form[1]);
          });
        } else {
          fn.merge(fn.peek(this.bindstack), fn.assertObject(form));
          return null;
        }
      });
      this.defspecial('Globals', (form) => {
        this.globals = fn.deepMerge(this.globals, fn.assertObject(form));
        this.bindstack.push(fn.deepMerge(this.bindstack.pop(), form));
        return null;
      });
      this.defspecial('Mappings', (form = {}) => {
        this.maps = fn.deepMerge(this.maps, form);
        return {
          Mappings: this.maps
        };
      });
      this.defspecial('Do', (form) => {
        return fn.assertArray(form).reduce(((xs, x) => {
          return this.walk(x);
        }), null);
      });
      //=========================================================================#
      // Define custom macros.                                                   #
      //=========================================================================#
      this.defmacro('Require', (form) => {
        var j, len, ref1, v;
        ref1 = (fn.isArray(form) ? form : [form]);
        for (j = 0, len = ref1.length; j < len; j++) {
          v = ref1[j];
          v = path.resolve(v);
          require(v)(new CfnModule(this, v));
        }
        return null;
      });
      this.defmacro('Parameters', (form) => {
        return {
          Parameters: form.reduce(((xs, param) => {
            var name, opts;
            [name, ...opts] = param.split(/ +/);
            opts = fn.merge({
              Type: 'String'
            }, parseKeyOpts(opts));
            return fn.merge(xs, fn.hashMap(name, opts));
          }), {})
        };
      });
      this.defmacro('Return', (form) => {
        log.warn(this.atLocation('!Return was deprecated in 4.2.0: use !Outputs instead'));
        return {
          'Fn::Outputs': form
        };
      });
      this.defmacro('Outputs', (form) => {
        return {
          Outputs: fn.reduceKv(form, (xs, k, v) => {
            var name, opts, xport;
            [name, ...opts] = k.split(/ +/);
            xport = fn.notEmpty(opts = parseKeyOpts(opts)) ? {
              Export: opts
            } : void 0;
            return fn.merge(xs, fn.hashMap(name, fn.merge({
              Value: v
            }, xport)));
          })
        };
      });
      this.defmacro('Resources', (form) => {
        var Type, body, id, m, opts, ret;
        ret = {};
        for (id in form) {
          body = form[id];
          [id, Type, ...opts] = id.split(/ +/);
          id = this.walk({
            'Fn::Sub': id
          });
          ret[id] = !Type ? (m = this.resourceMacros[body.Type]) ? m(body) : body : (body = fn.merge({Type}, parseKeyOpts(opts), {
            Properties: body
          }), (m = this.resourceMacros[Type]) ? m(body) : body);
        }
        return {
          Resources: ret
        };
      });
      this.defmacro('Attr', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return {
          'Fn::GetAtt': fn.split(form, '.', 2).map((x) => {
            return {
              'Fn::Sub': x
            };
          })
        };
      });
      this.defmacro('Get', (form) => {
        form = fn.isArray(form) && form.length === 1 ? form[0] : form;
        if (fn.isString(form)) {
          form = form.split('.');
        }
        return {
          'Fn::FindInMap': form.map((x) => {
            return {
              'Fn::Sub': x
            };
          })
        };
      });
      this.defmacro('Env', (form) => {
        var ret;
        form = fn.isArray(form) ? form[0] : form;
        ret = process.env[form];
        if (!ret) {
          throw new CfnError(`required environment variable not set: ${form}`);
        }
        return ret;
      });
      this.defmacro('Var', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return {
          'Fn::ImportValue': {
            'Fn::Sub': form
          }
        };
      });
      this.defmacro('Shell', (form) => {
        var env, vars;
        [vars = {}, form = ''] = (function() {
          switch (false) {
            case !(fn.isArray(form) && form.length === 2):
              return form;
            case !(fn.isArray(form) && form.length === 1):
              return [null].concat(form);
            case !fn.isString(form):
              return [null, form];
            default:
              throw new CfnError('expected <string> or [<object>, <string>]');
          }
        })();
        env = Object.assign({}, process.env, vars);
        return this.withCache({
          shell: [this.ns, this.template, vars, form]
        }, () => {
          return (fn.execShell(form, {env}) || '').replace(/\n$/, '');
        });
      });
      this.defmacro('Js', (form) => {
        var vars;
        [vars = {}, form = ''] = (function() {
          switch (false) {
            case !(fn.isArray(form) && form.length === 2):
              return form;
            case !(fn.isArray(form) && form.length === 1):
              return [{}].concat(form);
            case !fn.isString(form):
              return [{}, form];
            default:
              throw new CfnError('expected <string> or [<object>, <string>]');
          }
        })();
        return this.withCache({
          js: [this.ns, this.template, vars, form]
        }, () => {
          var args, ret, vals;
          args = Object.keys(vars);
          vals = args.reduce((function(xs, x) {
            return xs.concat([`(${JSON.stringify(vars[x])})`]);
          }), []);
          form = `return (function(${args.join(', ')}) {
  ${form}
}).bind(arguments[0]).call(null, ${vals.join(', ')})`;
          ret = this.walk((new Function(form)).call(null, new CfnModule(this)));
          if (ret == null) {
            throw new CfnError('expected non-null result', form);
          }
          return ret;
        });
      });
      this.defmacro('Package', (form) => {
        return this.packageMacro(form);
      });
      this.defmacro('PackageURL', (form) => {
        var S3Bucket, S3Key;
        ({S3Bucket, S3Key} = this.packageMacro(form));
        return `https://s3.amazonaws.com/${S3Bucket}/${S3Key}`;
      });
      this.defmacro('PackageURI', (form) => {
        var S3Bucket, S3Key;
        ({S3Bucket, S3Key} = this.packageMacro(form));
        return `s3://${S3Bucket}/${S3Key}`;
      });
      this.defmacro('PackageTemplateURL', (form) => {
        var S3Bucket, S3Key;
        ({S3Bucket, S3Key} = this.packageMacro(form, {
          Parse: true
        }));
        return `https://s3.amazonaws.com/${S3Bucket}/${S3Key}`;
      });
      this.defmacro('YamlParse', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return yaml.safeLoad(form);
      });
      this.defmacro('YamlDump', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return yaml.safeDump(form);
      });
      this.defmacro('JsonParse', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return JSON.parse(form);
      });
      this.defmacro('JsonDump', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return JSON.stringify(form);
      });
      this.defmacro('File', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return this.withCache({
          file: [this.ns, path.resolve(form)]
        }, () => {
          return fs.readFileSync(form);
        });
      });
      this.defmacro('TemplateFile', (form) => {
        form = fn.isArray(form) ? form[0] : form;
        return this.withCache({
          templateFile: [this.ns, path.resolve(form)]
        }, () => {
          return yaml.safeLoad(this.transformTemplateFile(form, true));
        });
      });
      this.defmacro('Merge', (form) => {
        return fn.merge.apply(null, form);
      });
      this.defmacro('DeepMerge', (form) => {
        return fn.deepMerge.apply(null, form);
      });
      this.defmacro('Tags', (form) => {
        var j, k, len, ref1, results;
        ref1 = Object.keys(form);
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          k = ref1[j];
          results.push({
            Key: k,
            Value: form[k]
          });
        }
        return results;
      });
      this.defresource('Stack', (form) => {
        var Parameters, Properties, Type, k, ref1, stackProps, v;
        Type = 'AWS::CloudFormation::Stack';
        Parameters = {};
        Properties = {Parameters};
        stackProps = Object.keys(ResourceTypes[Type].Properties);
        ref1 = form.Properties || {};
        for (k in ref1) {
          v = ref1[k];
          (indexOf.call(stackProps, k) >= 0 ? Properties : Parameters)[k] = v;
        }
        return fn.merge(form, {Type, Properties});
      });
    }

    withCache(key, f) {
      key = JSON.stringify(key);
      return (this.cache[key] || (this.cache[key] = [f()]))[0];
    }

    packageMacro(form, opts) {
      var CacheKey, Parse, Path;
      form = fn.isArray(form) ? form[0] : form;
      if (fn.isString(form)) {
        form = {
          Path: form
        };
      }
      form = Object.assign(form, opts);
      ({Path, CacheKey, Parse} = form);
      if (this.opts.dopackage) {
        this.needBucket = true;
        return this.withCache({
          package: [this.ns, this.userPath(Path), CacheKey, Parse]
        }, () => {
          return ((function() {
            switch (false) {
              case !fn.isDirectory(Path):
                return this.writeDir(Path, CacheKey);
              case !Parse:
                return this.writeTemplate(Path, CacheKey);
              default:
                return this.writeFile(Path, CacheKey);
            }
          }).call(this)).code;
        });
      } else {
        return {
          S3Bucket: 'example-bucket',
          S3Key: `${this.opts.s3prefix}example-key`
        };
      }
    }

    wrapError(e) {
      switch (false) {
        case e.name !== 'CfnError':
          return e;
        case e.name !== 'Error':
          return new CfnError(e.message);
        default:
          return new CfnError(`${e.name}: ${e.message}`);
      }
    }

    atLocation(message) {
      var msg;
      msg = [];
      if (message) {
        msg.push(message);
      }
      if (this.template) {
        msg.push(`in ${this.template}`);
      }
      if (this.keystack.length) {
        msg.push(`at ${this.keystack.join('/')}`);
      }
      return msg.join('\n');
    }

    abort(e) {
      e = this.wrapError(e);
      if (!e.aborting) {
        e.message = this.atLocation(e.message);
      }
      e.aborting = true;
      throw e;
    }

    withCwd(dir, f) {
      var old;
      old = process.cwd();
      process.chdir(dir);
      try {
        return f();
      } finally {
        process.chdir(old);
      }
    }

    withKeyStack(ks, f) {
      var old, ret;
      [this.keystack, old] = [ks, this.keystack];
      ret = f();
      this.keystack = old;
      return ret;
    }

    withBindings(bindings, f) {
      var ret;
      this.bindstack.push(fn.merge({}, fn.peek(this.bindstack), fn.assertObject(bindings)));
      ret = f();
      this.bindstack.pop();
      return ret;
    }

    canonicalKeyPath() {
      return [this.template].concat(this.keystack);
    }

    canonicalHash(fileOrDir, key) {
      if (key) {
        return fn.md5(JSON.stringify([this.canonicalKeyPath(), key]));
      } else {
        return fn.md5Path(fileOrDir);
      }
    }

    writePaths(fileName, ext = '') {
      if (this.needBucket && !this.opts.s3bucket) {
        throw new CfnError("can't generate S3 URL: no S3 bucket configured");
      }
      fileName = `${fileName}${ext}`;
      return {
        nested: this.nested,
        tmpPath: this.tmpPath(fileName),
        code: {
          S3Bucket: this.opts.s3bucket,
          S3Key: `${this.opts.s3prefix}${fileName}`
        }
      };
    }

    writeText(text, ext, key, source = 'none') {
      var ret;
      ret = this.writePaths(fn.md5(key || text), ext);
      log.verbose(`wrote '${this.userPath(source)}' -> '${ret.tmpPath}'`);
      fs.writeFileSync(ret.tmpPath, text);
      return ret;
    }

    transformTemplateFile(file, ignoreNested) {
      var ret, xformer;
      xformer = new this.constructor({ns: this.ns, basedir: this.basedir, cache: this.cache, opts: this.opts, maps: this.maps, globals: this.globals, state: this.state});
      ret = xformer.transformFile(file);
      if (!ignoreNested) {
        this.nested = this.nested.concat(xformer.nested);
      }
      return ret;
    }

    lint(file) {
      var cmd;
      log.verbose(`linting '${this.template}'`);
      cmd = `${this.opts.linter} ${file}`;
      return this.withCwd(this.basedir, (() => {
        return fn.tryExecRaw(cmd, 'lint error');
      }));
    }

    validate(file) {
      var cmd;
      log.verbose(`validating '${this.template}'`);
      cmd = `aws cloudformation validate-template --template-body "$(cat '${file}')"`;
      return fn.tryExecRaw(cmd, 'aws cloudformation validation error');
    }

    writeTemplate(file, key) {
      var e;
      try {
        this.template = this.userPath(file);
        return this.withKeyStack([], () => {
          var ret;
          ret = this.writeText(this.transformTemplateFile(file), fn.fileExt(file), key, file);
          if (this.opts.linter) {
            this.lint(ret.tmpPath);
          }
          if (this.opts.dovalidate) {
            this.validate(ret.tmpPath);
          }
          return ret;
        });
      } catch (error) {
        e = error;
        return this.abort(e);
      }
    }

    writeFile(file, key) {
      var ret;
      ret = this.writePaths(this.canonicalHash(file, key), fn.fileExt(file));
      log.verbose(`wrote '${this.userPath(file)}' -> '${ret.tmpPath}'`);
      fs.copyFileSync(file, ret.tmpPath);
      return ret;
    }

    writeDir(dir, key) {
      var ret, tmpZip;
      tmpZip = this.tmpPath(`${encodeURIComponent(this.userPath(dir))}.zip`);
      log.verbose(`packaging: '${dir}'`);
      fn.execShell(`zip -qr ${tmpZip} .`, {
        cwd: dir
      });
      ret = this.writePaths(this.canonicalHash(dir, key), '.zip');
      log.verbose(`wrote '${this.userPath(dir)}' -> '${ret.tmpPath}'`);
      fs.renameSync(tmpZip, ret.tmpPath);
      return ret;
    }

    userPath(file) {
      var ret;
      ret = path.relative(this.basedir, file);
      if (ret.startsWith('../')) {
        return path.resolve(ret);
      } else {
        return ret;
      }
    }

    tmpPath(name) {
      return path.join(this.opts.tmpdir, name);
    }

    pushFile(file, f) {
      var old, ret;
      this.nested.push(this.userPath(file));
      [old, this.template] = [this.template, this.userPath(file)];
      log.verbose(`transforming '${this.template}'`);
      ret = this.withCwd(path.dirname(file), (function() {
        return f(path.basename(file));
      }));
      this.template = old;
      return ret;
    }

    pushFileCaching(file, f) {
      return this.withCache({
        pushFileCaching: [this.ns, this.userPath(file)]
      }, () => {
        return this.pushFile(file, f);
      });
    }

    defresource(type, emit) {
      this.resourceMacros[type] = emit;
      return this;
    }

    transform(text) {
      this.bindstack = [{}];
      return super.transform(text);
    }

    transformFile(templateFile, doc) {
      var e;
      try {
        doc = doc || fs.readFileSync(templateFile).toString('utf-8');
        return this.pushFileCaching(templateFile, (file) => {
          return this.transform(doc);
        });
      } catch (error) {
        e = error;
        return this.abort(e);
      }
    }

  };

  module.exports = CfnTransformer;

}).call(this);

//# sourceMappingURL=cfn-transformer.js.map
