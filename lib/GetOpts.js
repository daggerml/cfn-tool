// Generated by CoffeeScript 2.5.1
(function() {
  var CfnError, GetOpts, fn, fs, getopts, inspect, log, path, uuid,
    indexOf = [].indexOf;

  fs = require('fs');

  getopts = require('getopts');

  ({inspect} = require('util'));

  path = require('path');

  uuid = require('uuid');

  fn = require('./fn');

  log = require('./log');

  CfnError = require('./CfnError');

  GetOpts = class GetOpts {
    constructor(master) {
      this.master = master;
    }

    
    // HELPER METHODS

    allOpts() {
      return this.config.boolean.concat(this.config.string);
    }

    allPos() {
      return this.config.positional;
    }

    allVars() {
      return Object.keys(this.var2opt());
    }

    configVars() {
      return Object.keys(fn.invertObj(fn.selectKeys(this.opt2var(), this.allOpts())));
    }

    useVars() {
      return Object.keys(this.var2opt()).reduce((xs, x) => {
        if (this.env[x] != null) {
          return xs.concat([x]);
        } else {
          return xs;
        }
      }, []);
    }

    opt2var(x) {
      if (x) {
        return this.master.opt2var(x);
      } else {
        return this.allOpts().reduce(((xs, x) => {
          return fn.assoc(xs, x, this.opt2var(x));
        }), {});
      }
    }

    var2opt(x) {
      var inv;
      inv = fn.invertObj(this.opt2var());
      if (x) {
        return inv[x];
      } else {
        return inv;
      }
    }

    config2opt(k, v) {
      if (!(indexOf.call(this.config.boolean, k) >= 0)) {
        return v;
      } else {
        return v === 'true';
      }
    }

    getVars() {
      return this.allOpts().reduce((xs, x) => {
        var v;
        v = this.env[this.opt2var(x)];
        if (v != null) {
          return fn.assoc(xs, x, this.config2opt(x, v));
        } else {
          return xs;
        }
      }, {});
    }

    setVars(opts, {clobber = false} = {}) {
      var o, ref, v;
      ref = this.opt2var();
      for (o in ref) {
        v = ref[o];
        if ((opts[o] != null) && (clobber || !(indexOf.call(this.useVars(), v) >= 0))) {
          this.env[v] = `${opts[o]}`;
        }
      }
      return this.fixRegion();
    }

    setLogLevel(opts) {
      log.level((function() {
        switch (false) {
          case !opts.verbose:
            return 'verbose';
          case !opts.quiet:
            return 'error';
          default:
            return 'info';
        }
      })());
      return opts;
    }

    fixRegion() {
      var r1, r2;
      [r1, r2] = [this.env.AWS_REGION, this.env.AWS_DEFAULT_REGION];
      if ((r2 && !r1) || (r1 && r2 && r1 !== r2)) {
        this.env.AWS_REGION = r2;
      }
      if (r1 && !r2) {
        return this.env.AWS_DEFAULT_REGION = r1;
      }
    }

    loadConfig(opts, file) {
      var e, parse, pat, ref, uid, vars;
      if (!((ref = (vars = this.configVars())) != null ? ref.length : void 0)) {
        return;
      }
      log.verbose(`using config file: '${file}'`);
      try {
        uid = uuid.v4();
        pat = `^\\(${this.configVars().join('\\|')}\\)$`;
        parse = (x) => {
          var lines;
          lines = x.split('\n').map(function(x) {
            return x.trim();
          }).filter(fn.identity);
          lines = lines.slice(lines.indexOf(uid) + 2);
          return lines.reduce((xs, line) => {
            var k, v;
            [k, v] = fn.split(line, '=', 2);
            k = this.var2opt(k);
            v = Buffer.from(v, 'base64').toString('utf-8');
            if (k) {
              return fn.assoc(xs, k, this.config2opt(k, v));
            } else {
              return xs;
            }
          }, {});
        };
        this.setVars(opts);
        return this.setVars(parse(fn.execShell(`. '${file}'
echo
echo ${uid}
for i in $(compgen -A variable |grep '${pat}'); do
  echo $i=$(echo -n "\${!i}" |base64 -w0)
done`)));
      } catch (error) {
        e = error;
        e.message = e.message.split('\n').shift();
        throw e;
      }
    }

    getopts(argv, dfl) {
      var arg, args, i, j, k, len, opts, ref;
      opts = getopts(argv, dfl);
      args = this.config.positional;
      ref = opts._;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        arg = ref[i];
        ((k = args[i]) ? opts[k] = arg : void 0);
      }
      return fn.selectKeys(opts, this.allOpts().concat(this.allPos()));
    }

    
    // EXTERNAL API

    configure(opts = [], env, abort = true) {
      var optf;
      this.env = env;
      optf = function(x) {
        return indexOf.call(opts, x) >= 0;
      };
      this.fixRegion();
      return this.config = {
        alias: fn.selectKeys(this.master.alias, opts),
        boolean: this.master.boolean.slice().filter(optf),
        string: Object.keys(this.master.string).filter(optf),
        positional: Object.keys(this.master.positional).filter(optf),
        unknown: abort ? this.master.unknown : (function(x) {})
      };
    }

    usage() {
      var alias, args, bools, optarg, optbool, optpos, optstr, strs;
      bools = this.config.boolean;
      strs = this.config.string;
      args = this.config.positional;
      alias = (x) => {
        var y;
        if ((y = this.config.alias[x])) {
          return `-${y}, `;
        } else {
          return '';
        }
      };
      optbool = (x) => {
        return `[${alias(x)}--${x}]`;
      };
      optstr = (x) => {
        return `[${alias(x)}--${x}=${this.master.string[x]}]`;
      };
      optarg = (x) => {
        if (indexOf.call(bools, x) >= 0) {
          return optbool(x);
        } else {
          return optstr(x);
        }
      };
      optpos = (x) => {
        return this.master.positional[x];
      };
      return bools.concat(strs).sort().map(optarg).concat(args.map(optpos).filter(fn.identity));
    }

    parse(argv, {key, file, noenv} = {}) {
      var cfg, conf, opts;
      conf = () => {
        return fn.assoc(this.config, 'default', noenv ? {} : this.getVars());
      };
      opts = this.setLogLevel(this.getopts(argv, conf()));
      if ((cfg = opts[key] || file) && fs.existsSync(cfg)) {
        this.loadConfig(opts, cfg);
        opts = this.setLogLevel(this.getopts(argv, conf()));
      }
      this.setVars(opts, {
        clobber: true
      });
      log.verbose("configuration options", {
        body: inspect(opts, {
          depth: null
        })
      });
      return opts;
    }

    validateArgs(opts) {
      var i, j, k, len, ref, results;
      ref = this.config.positional;
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        k = ref[i];
        results.push(fn.assertOk(opts[k], `${this.master.positional[k] || k} argument required`));
      }
      return results;
    }

    completeOpt(words = []) {
      var longs, used;
      used = fn.objKeys(this.parse(words, {
        noenv: true
      })).map(function(x) {
        return `--${x}`;
      });
      longs = this.allOpts().map(function(x) {
        return `--${x}`;
      });
      return longs.sort().filter(function(x) {
        return !(indexOf.call(used, x) >= 0);
      });
    }

  };

  module.exports = GetOpts;

}).call(this);

//# sourceMappingURL=GetOpts.js.map
