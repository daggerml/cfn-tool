// Generated by CoffeeScript 2.5.1
(function() {
  var AWS_VERSIONS, CfnError, CfnTransformer, GetOpts, VERSION, abort, allCmds, assert, bashCompletion, completions, defaultOptionsSpec, fn, fs, log, options, optionsSpecs, os, path, quit, sq, usage, usageCmd, version, yaml,
    indexOf = [].indexOf;

  fs = require('fs');

  os = require('os');

  path = require('path');

  sq = require('shell-quote');

  GetOpts = require('./lib/GetOpts');

  yaml = require('js-yaml');

  ({
    strict: assert
  } = require('assert'));

  completions = require('./lib/completions');

  fn = require('./lib/fn');

  log = require('./lib/log');

  CfnError = require('./lib/CfnError');

  CfnTransformer = require('./lib/cfn-transformer');

  ({
    version: VERSION
  } = require('./package.json'));

  AWS_VERSIONS = [1, 2];

  quit = function(msg, status = 0) {
    if (msg) {
      console.log(msg);
    }
    return process.exit(status);
  };

  abort = function(e) {
    var body;
    if (e.code === 'ENOENT') {
      e = new CfnError(e.message);
    }
    body = e instanceof CfnError ? e.body : e.body || e.stack;
    log.error(e.message, {body});
    return process.exit(1);
  };

  process.on('uncaughtException', abort);

  options = new GetOpts({
    alias: {
      bucket: 'b',
      config: 'c',
      help: 'h',
      keep: 'k',
      linter: 'l',
      parameters: 'P',
      profile: 'p',
      quiet: 'q',
      region: 'r',
      tags: 't',
      verbose: 'v',
      version: 'V'
    },
    boolean: ['help', 'keep', 'quiet', 'verbose', 'version'],
    string: {
      bucket: '<name>',
      config: '<file>',
      linter: '<command>',
      parameters: '"<key>=<val> ..."',
      profile: '<name>',
      region: '<name>',
      tags: '"<key>=<val> ..."'
    },
    positional: {
      command: null,
      template: '<template-file>',
      stackname: '<stack-name>'
    },
    opt2var: function(opt) {
      switch (opt) {
        case 'profile':
          return 'AWS_PROFILE';
        case 'region':
          return 'AWS_REGION';
        default:
          return `CFN_TOOL_${opt.toUpperCase()}`;
      }
    },
    complete: {
      bucket: completions.none,
      config: completions.none,
      linter: completions.none,
      parameters: completions.none,
      profile: completions.profile,
      region: completions.region,
      tags: completions.none,
      template: completions.none,
      stackname: completions.none
    },
    unknown: function(x) {
      return abort(new CfnError(`unknown option: '${x}'`));
    }
  });

  defaultOptionsSpec = ['help', 'version', 'command'];

  optionsSpecs = {
    deploy: ['bucket', 'config', 'help', 'keep', 'linter', 'parameters', 'profile', 'quiet', 'region', 'tags', 'verbose', 'command', 'template', 'stackname'],
    transform: ['config', 'help', 'linter', 'profile', 'quiet', 'region', 'tags', 'verbose', 'command', 'template'],
    update: ['config', 'help', 'parameters', 'profile', 'quiet', 'region', 'verbose', 'command', 'stackname']
  };

  allCmds = Object.keys(optionsSpecs);

  usageCmd = function(prog, cmd) {
    var lpad, opts;
    options.configure(cmd ? optionsSpecs[cmd] : defaultOptionsSpec);
    lpad = function(x) {
      return `  ${x}`;
    };
    opts = options.usage().map(lpad).join("\n");
    return `${prog}${cmd ? ` ${cmd}` : ''}${opts ? `\n${opts}` : ''}`;
  };

  usage = function(prog, cmd, status) {
    var manp, text, ucmd;
    manp = [prog].concat(cmd ? [cmd] : []).join('-');
    ucmd = fn.partial(usageCmd, null, prog);
    text = cmd ? ucmd(cmd) : [null].concat(allCmds).map(ucmd).join("\n\n");
    return quit(`${text}

See the manpage:
* cmd: man ${manp}
* url: http://htmlpreview.github.io/?https://github.com/daggerml/cfn-tool/blob/${VERSION}/man/${manp}.html`, status);
  };

  version = function() {
    return quit(VERSION);
  };

  bashCompletion = function([$0, prefix, prev]) {
    var c, command, i, len, opts, ref, spec, words, x;
    log.transports.forEach(function(x) {
      return x.silent = true;
    });
    words = sq.parse(process.env.COMP_LINE).slice(1);
    if (prefix) {
      words.pop();
    }
    command = words[0];
    if ($0 === prev && words.length < 2) {
      options.configure(defaultOptionsSpec, false);
      quit(completions.list(prefix, allCmds.concat(options.completeOpt(words))));
    } else if ((spec = optionsSpecs[command])) {
      fs.writeFileSync('/tmp/t', "got here 1");
      options.configure(spec, false);
      opts = options.completeOpt();
      if (indexOf.call(opts, prev) >= 0) {
        if ((c = options.master.complete[prev.replace(/^-+/, '')])) {
          quit(c(prefix));
        }
      }
      if (prefix.startsWith('-')) {
        quit(completions.list(prefix, options.completeOpt(words)));
      }
      opts = options.parse(words, {
        noenv: true
      });
      ref = options.config.positional;
      for (i = 0, len = ref.length; i < len; i++) {
        x = ref[i];
        if (opts[x]) {
          continue;
        }
        if ((c = options.master.complete[x])) {
          quit(c(prefix));
        }
      }
      quit();
    }
    return quit(completions.file(prefix));
  };

  module.exports = function(completionArgs) {
    var argv, bucketarg, cfn, cmdKnown, haveOverride, i, k, len, opts, params, paramsarg, prog, ref, ref1, ref2, ref3, ref4, ref5, res, spec, tagsarg, v, x;
    if (completionArgs) {
      bashCompletion(completionArgs);
    }
    if ((spec = optionsSpecs[process.argv[2]])) {
      options.configure(spec);
    } else {
      options.configure(defaultOptionsSpec, false);
    }
    prog = path.basename(process.argv[1]);
    argv = process.argv.slice(2);
    opts = options.parse(argv, {
      key: 'config',
      file: '.cfn-tool'
    });
    opts.tmpdir = fn.tmpdir('cfn-tool-', opts.keep);
    cmdKnown = (ref = opts.command, indexOf.call(allCmds, ref) >= 0) || !opts.command;
    fn.assertOk(cmdKnown, `unknown command: '${opts.command}'`);
    switch (false) {
      case !opts.help:
        usage(prog, opts.command);
        break;
      case !opts.version:
        version();
        break;
      case !!opts.command:
        usage(prog, null, 1);
    }
    options.validateArgs(opts);
    switch (opts.command) {
      case 'transform':
        Object.assign(opts, {
          dovalidate: false,
          dopackage: false,
          bucket: 'example-bucket',
          s3bucket: 'example-bucket'
        });
        log.verbose('preparing template');
        cfn = new CfnTransformer({opts});
        res = cfn.writeTemplate(opts.template);
        console.log(fs.readFileSync(res.tmpPath).toString('utf-8').trimRight());
        break;
      case 'deploy':
        Object.assign(opts, {
          dovalidate: true,
          dopackage: true,
          s3bucket: opts.bucket
        });
        log.info('preparing templates');
        cfn = new CfnTransformer({opts});
        res = cfn.writeTemplate(opts.template);
        if (res.nested.length > 1) {
          if (!opts.bucket) {
            throw new CfnError('bucket required for nested stacks');
          }
          log.info('uploading templates to S3');
          fn.execShell(`aws s3 sync --size-only '${cfn.tmpdir}' 's3://${opts.bucket}/'`);
        }
        if (opts.bucket) {
          bucketarg = `--s3-bucket '${opts.bucket}' --s3-prefix aws/`;
        }
        if (opts.parameters) {
          paramsarg = `--parameter-overrides ${opts.parameters}`;
        }
        if (opts.tags) {
          tagsarg = `--tags ${opts.tags}`;
        }
        log.info('deploying stack');
        fn.execShell(`aws cloudformation deploy --template-file '${res.tmpPath}' --stack-name '${opts.stackname}' --capabilities CAPABILITY_NAMED_IAM CAPABILITY_IAM CAPABILITY_AUTO_EXPAND ${bucketarg || ''} ${paramsarg || ''} ${tagsarg || ''}`);
        log.info('done -- no errors');
        break;
      case 'update':
        res = JSON.parse(fn.execShell(`aws cloudformation describe-stacks --stack-name '${opts.stackname}'`));
        params = res != null ? (ref1 = res.Stacks) != null ? (ref2 = ref1[0]) != null ? (ref3 = ref2.Parameters) != null ? ref3.reduce(function(xs, x) {
          var k;
          k = x.ParameterKey;
          return fn.assoc(xs, k, `ParameterKey=${k},UsePreviousValue=true`);
        }, {}) : void 0 : void 0 : void 0 : void 0;
        fn.assertOk(Object.keys(params).length, `stack '${opts.stackname}' has no parameters`);
        haveOverride = null;
        ref5 = ((ref4 = opts.parameters) != null ? ref4.split(/ +/) : void 0) || [];
        for (i = 0, len = ref5.length; i < len; i++) {
          x = ref5[i];
          [k, v] = fn.split(x, '=', 2);
          fn.assertOk(k && v, `parameter: expected <key>=<value>: got '${x}'`);
          fn.assertOk(params[k], `stack '${opts.stackname}' has no parameter '${k}'`);
          haveOverride = params[k] = `ParameterKey=${k},ParameterValue=${v}`;
        }
        fn.assertOk(haveOverride, 'parameter overrides required');
        paramsarg = objVals(params).join(' ');
        fn.execShell(`echo aws cloudformation update-stack --stack-name ${opts.stackname} --parameters ${paramsarg} --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM CAPABILITY_AUTO_EXPAND ----use-previous-template`);
        log.info('done -- no errors');
    }
    return quit();
  };

}).call(this);

//# sourceMappingURL=index.js.map
