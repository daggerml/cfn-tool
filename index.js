// Generated by CoffeeScript 2.5.1
(function() {
  var CfnError, CfnExit, CfnTool, CfnTransformer, GetOpts, VERSION, assert, completions, fn, fs, log, os, path, sq, yaml,
    indexOf = [].indexOf;

  fs = require('fs');

  os = require('os');

  path = require('path');

  sq = require('shell-quote');

  GetOpts = require('./lib/GetOpts');

  yaml = require('js-yaml');

  ({
    strict: assert
  } = require('assert'));

  completions = require('./lib/completions');

  fn = require('./lib/fn');

  log = require('./lib/log');

  CfnError = require('./lib/CfnError');

  CfnExit = require('./lib/CfnExit');

  CfnTransformer = require('./lib/cfn-transformer');

  ({
    version: VERSION
  } = require('./package.json'));

  CfnTool = class CfnTool {
    constructor() {
      this.options = new GetOpts({
        alias: {
          bucket: 'b',
          help: 'h',
          keep: 'k',
          linter: 'l',
          parameters: 'P',
          profile: 'p',
          quiet: 'q',
          region: 'r',
          tags: 't',
          verbose: 'v',
          version: 'V'
        },
        boolean: ['help', 'keep', 'quiet', 'verbose', 'version'],
        string: {
          bucket: '<name>',
          linter: '<command>',
          parameters: '"<key>=<val> ..."',
          profile: '<name>',
          region: '<name>',
          tags: '"<key>=<val> ..."'
        },
        positional: {
          command: null,
          template: '<template-file>',
          stackname: '<stack-name>'
        },
        complete: {
          bucket: completions.none,
          linter: completions.none,
          parameters: completions.none,
          profile: completions.profile,
          region: completions.region,
          tags: completions.none,
          template: completions.none,
          stackname: completions.none
        },
        unknown: (x) => {
          return this.abort(new CfnError(`unknown option: '${x}'`));
        }
      });
      this.defaultOptionsSpec = ['help', 'version', 'command'];
      this.optionsSpecs = {
        deploy: ['bucket', 'help', 'keep', 'linter', 'parameters', 'profile', 'quiet', 'region', 'tags', 'verbose', 'command', 'template', 'stackname'],
        transform: ['help', 'linter', 'profile', 'quiet', 'region', 'verbose', 'command', 'template'],
        update: ['help', 'parameters', 'profile', 'quiet', 'region', 'verbose', 'command', 'stackname']
      };
      this.opts = {};
      this.allCmds = Object.keys(this.optionsSpecs);
    }

    exit(status = 0) {
      this.exitStatus = status;
      this.sideEffects = log.sideEffects();
      throw new CfnExit(status);
    }

    quit(msg, status = 0) {
      log.console(msg);
      return this.exit(status);
    }

    abort(e) {
      var body;
      if (e.code === 'ENOENT') {
        e = new CfnError(e.message);
      }
      body = e instanceof CfnError ? e.body : e.body || e.stack;
      log.error(e.message, {body});
      return this.exit(1);
    }

    usageCmd(prog, cmd) {
      var lpad, opts;
      this.options.configure((cmd ? this.optionsSpecs[cmd] : this.defaultOptionsSpec), this.env);
      lpad = function(x) {
        return `  ${x}`;
      };
      opts = this.options.usage().map(lpad).join("\n");
      cmd = cmd ? ` ${cmd}` : '';
      opts = opts ? `\n${opts}` : '';
      return `${prog}${cmd}${opts}`;
    }

    usage(prog, cmd, status) {
      var manp, text, ucmd;
      manp = [prog].concat(cmd ? [cmd] : []).join('-');
      ucmd = fn.partial(this.usageCmd, this, prog);
      text = cmd ? ucmd(cmd) : [null].concat(this.allCmds).map(ucmd).join("\n\n");
      return this.quit(`${text}

See the manpage:
* cmd: man ${manp}
* url: http://htmlpreview.github.io/?https://github.com/daggerml/cfn-tool/blob/${VERSION}/man/${manp}.html`, status);
    }

    version() {
      return this.quit(VERSION);
    }

    setAwsEnv(opts) {
      var r1, r2;
      if (opts.region) {
        (this.env.AWS_REGION = this.env.AWS_DEFAULT_REGION = opts.region);
      }
      if (opts.profile) {
        (this.env.AWS_PROFILE = opts.profile);
      }
      [r1, r2] = [this.env.AWS_REGION, this.env.AWS_DEFAULT_REGION];
      if ((r2 && !r1) || (r1 && r2 && r1 !== r2)) {
        this.env.AWS_REGION = r2;
      }
      if (r1 && !r2) {
        this.env.AWS_DEFAULT_REGION = r1;
      }
      return opts;
    }

    setLogLevel(opts) {
      log.level((function() {
        switch (false) {
          case !opts.verbose:
            return 'verbose';
          case !opts.quiet:
            return 'error';
          default:
            return 'info';
        }
      })());
      return opts;
    }

    //----------------------------------------------------------------------------
    // PUBLIC API
    //----------------------------------------------------------------------------
    test(f) {
      var e;
      fn.testing(true);
      try {
        return f();
      } catch (error) {
        e = error;
        if (e.name === 'CfnExit') {
          return fn.testing(false) || this;
        } else {
          return this.test(() => {
            return this.abort(e);
          });
        }
      }
    }

    prod(f) {
      var e;
      try {
        return f();
      } catch (error) {
        e = error;
        if (e.name === 'CfnExit') {
          return process.exit(e.status);
        } else {
          return this.prod(() => {
            return this.abort(e);
          });
        }
      }
    }

    complete(argv, env) {
      var $0, c, cl, command, cp, i, left, len, prefix, prev, ref, right, spec, suffix, words, x;
      this.env = env;
      log.level('console');
      [$0, prefix, prev] = argv.slice(2);
      cl = this.env.COMP_LINE;
      cp = parseInt(this.env.COMP_POINT);
      suffix = cl.slice(cp).match(/[^ ]*/);
      left = cl.slice(0, cp - prefix.length);
      right = cl.slice(cp + suffix.length);
      words = sq.parse([left, right].filter(function(x) {
        return x;
      }).join(' ')).slice(1);
      command = words[0];
      if ($0 === prev && words.length < 2) {
        this.options.configure(this.defaultOptionsSpec, this.env, false);
        this.quit(completions.list(prefix, this.allCmds.concat(this.options.completeOpt(words))));
      } else if ((spec = this.optionsSpecs[command])) {
        this.options.configure(spec, this.env, false);
        this.opts = this.options.completeOpt();
        if (indexOf.call(this.opts, prev) >= 0) {
          if ((c = this.options.master.complete[prev.replace(/^-+/, '')])) {
            this.quit(c(prefix));
          }
        }
        if (prefix.startsWith('-')) {
          this.quit(completions.list(prefix, this.options.completeOpt(words)));
        }
        this.opts = this.options.parse(words, {
          noenv: true
        });
        ref = this.options.config.positional;
        for (i = 0, len = ref.length; i < len; i++) {
          x = ref[i];
          if (this.opts[x]) {
            continue;
          }
          if ((c = this.options.master.complete[x])) {
            this.quit(c(prefix));
          }
        }
        this.quit();
      }
      return this.quit(completions.file(prefix));
    }

    cli(argv, env) {
      var cfn, cmdKnown, haveOverride, i, k, len, mkparams, params, paramsfile, prog, ref, ref1, ref2, ref3, ref4, res, spec, v, x;
      this.env = env;
      if ((spec = this.optionsSpecs[argv[2]])) {
        this.options.configure(spec);
      } else {
        this.options.configure(this.defaultOptionsSpec);
      }
      prog = log.PROG;
      argv = argv.slice(2);
      this.opts = this.setLogLevel(this.setAwsEnv(this.options.parse(argv)));
      this.opts.tmpdir = fn.tmpdir('cfn-tool-', this.opts.keep);
      cmdKnown = (ref = this.opts.command, indexOf.call(this.allCmds, ref) >= 0) || !this.opts.command;
      fn.assertOk(cmdKnown, `unknown command: '${this.opts.command}'`);
      switch (false) {
        case !this.opts.help:
          this.usage(prog, this.opts.command);
          break;
        case !this.opts.version:
          this.version();
          break;
        case !!this.opts.command:
          this.usage(prog, null, 1);
      }
      this.options.validateArgs(this.opts);
      switch (this.opts.command) {
        case 'transform':
          Object.assign(this.opts, {
            dovalidate: false,
            dopackage: false,
            bucket: 'example-bucket',
            s3bucket: 'example-bucket'
          });
          log.verbose('preparing template');
          cfn = new CfnTransformer({opts: this.opts});
          res = cfn.writeTemplate(this.opts.template);
          log.console(fs.readFileSync(res.tmpPath).toString('utf-8').trimRight());
          break;
        case 'deploy':
          Object.assign(this.opts, {
            dovalidate: true,
            dopackage: true,
            s3bucket: this.opts.bucket
          });
          log.info('preparing templates');
          cfn = new CfnTransformer({opts: this.opts});
          res = cfn.writeTemplate(this.opts.template);
          if (res.nested.length > 1) {
            if (!this.opts.bucket) {
              throw new CfnError('bucket required for nested stacks');
            }
            log.info('uploading templates to S3');
            fn.execShell(fn.shprintf(`aws s3 sync --size-only %{%S} %{%S}`, this.opts.tmpdir, `s3://${this.opts.bucket}`));
          }
          mkparams = (x) => {
            var f, p;
            if (x) {
              p = JSON.stringify(sq.parse(x).map(function(x) {
                var k, v;
                [k, v] = fn.split(x, '=', 2);
                return {
                  ParameterKey: k,
                  ParameterValue: v
                };
              }));
              f = `${path.join(this.opts.tmpdir, fn.md5(p))}-params.json`;
              fs.writeFileSync(f, p);
              return `file://${f}`;
            }
          };
          log.info('deploying stack');
          fn.execShell(fn.shprintf(`aws cloudformation deploy --template-file %{%S} --stack-name %{%S} --capabilities CAPABILITY_NAMED_IAM CAPABILITY_IAM CAPABILITY_AUTO_EXPAND %{--s3-bucket %S }%{--parameter-overrides %S }%{--tags %A}`, res.tmpPath, this.opts.stackname, this.opts.bucket, mkparams(this.opts.parameters), this.opts.tags));
          log.info('done -- no errors');
          break;
        case 'update':
          res = JSON.parse(fn.execShell(`aws cloudformation describe-stacks --stack-name '${this.opts.stackname}'`));
          params = res != null ? (ref1 = res.Stacks) != null ? (ref2 = ref1[0]) != null ? (ref3 = ref2.Parameters) != null ? ref3.reduce(function(xs, x) {
            var k;
            k = x.ParameterKey;
            return fn.assoc(xs, k, {
              ParameterKey: k,
              UsePreviousValue: true
            });
          }, {}) : void 0 : void 0 : void 0 : void 0;
          fn.assertOk(Object.keys(params).length, `stack '${this.opts.stackname}' has no parameters`);
          haveOverride = null;
          if (this.opts.parameters) {
            ref4 = sq.parse(this.opts.parameters) || [];
            for (i = 0, len = ref4.length; i < len; i++) {
              x = ref4[i];
              [k, v] = fn.split(x, '=', 2);
              fn.assertOk(k && v, `parameter: expected <key>=<value>: got '${x}'`);
              fn.assertOk(params[k], `stack '${this.opts.stackname}' has no parameter '${k}'`);
              haveOverride = params[k] = {
                ParameterKey: k,
                ParameterValue: v
              };
            }
          }
          fn.assertOk(haveOverride, 'parameter overrides required');
          params = JSON.stringify(fn.objVals(params));
          paramsfile = `${path.join(this.opts.tmpdir, fn.md5(params))}-params.json`;
          fs.writeFileSync(paramsfile, params);
          paramsfile = `file://${paramsfile}`;
          fn.execShell(fn.shprintf(`aws cloudformation update-stack --stack-name %{%S} --parameters %{%S} --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM CAPABILITY_AUTO_EXPAND --use-previous-template`, this.opts.stackname, paramsfile));
          fn.execShell(fn.shprintf(`aws cloudformation wait stack-update-complete --stack-name %{%S}`, this.opts.stackname));
          log.info('done -- no errors');
      }
      return this.quit();
    }

  };

  module.exports = CfnTool;

}).call(this);

//# sourceMappingURL=index.js.map
